# Chat

## Context

You are an AI assistant helping with software development tasks.

**Current Date:** 2026-01-17 14:10:21

---

## Task Description

Analise o esquema de configuração @schema.json e verifique quais parametros ainda precisam ser implementados na aplicação omo-profiler.


---

## Rules & Constraints



---

## Project Structure

└── omo-profiler/
    ├── cmd/
    │   └── omo-profiler/
    │       └── main.go [441B]
    ├── internal/
    │   ├── backup/
    │   │   ├── backup.go [2.9KB]
    │   │   └── backup_test.go [6.8KB]
    │   ├── cli/
    │   │   ├── cmd/
    │   │   │   ├── current.go [660B]
    │   │   │   ├── export.go [1.4KB]
    │   │   │   ├── import.go [2.6KB]
    │   │   │   ├── list.go [947B]
    │   │   │   └── switch.go [1.1KB]
    │   │   └── root.go [851B]
    │   ├── config/
    │   │   ├── paths.go [1.2KB]
    │   │   ├── paths_test.go [2.7KB]
    │   │   ├── types.go [7.1KB]
    │   │   └── types_test.go [5.6KB]
    │   ├── diff/
    │   │   └── diff.go [2.5KB]
    │   ├── profile/
    │   │   ├── active.go [1.7KB]
    │   │   ├── active_test.go [5.2KB]
    │   │   ├── naming.go [648B]
    │   │   ├── naming_test.go [1.5KB]
    │   │   ├── profile.go [1.8KB]
    │   │   └── profile_test.go [4.4KB]
    │   ├── schema/
    │   │   ├── schema.json [62.3KB]
    │   │   ├── validator.go [1.9KB]
    │   │   └── validator_test.go [5.4KB]
    │   ├── testdata/
    │   │   ├── complex-permissions.json [268B]
    │   │   ├── minimal-config.json [85B]
    │   │   ├── skills-object.json [242B]
    │   │   └── valid-config.json [3.3KB]
    │   └── tui/
    │       ├── views/
    │       │   ├── dashboard.go [4.9KB]
    │       │   ├── diff.go [9.0KB]
    │       │   ├── editor.go [22.1KB]
    │       │   ├── list.go [5.8KB]
    │       │   ├── wizard.go [8.0KB]
    │       │   ├── wizard_agents.go [17.2KB]
    │       │   ├── wizard_hooks.go [5.9KB]
    │       │   ├── wizard_name.go [3.0KB]
    │       │   ├── wizard_other.go [21.0KB]
    │       │   └── wizard_review.go [4.9KB]
    │       ├── app.go [13.0KB]
    │       ├── keys.go [1.2KB]
    │       ├── styles.go [1.1KB]
    │       └── tui.go [178B]
    ├── Makefile [1.3KB]
    ├── README.md [1.2KB]
    ├── go.mod [1.8KB]
    ├── go.sum [8.6KB]
    └── schema.json [62.3KB]

<file path="cmd/omo-profiler/main.go">
package main

import (
	"os"

	"github.com/diogenes/omo-profiler/internal/cli"

	// Dependencies for future implementation
	_ "github.com/charmbracelet/bubbles/list"
	_ "github.com/charmbracelet/bubbletea"
	_ "github.com/charmbracelet/lipgloss"
	_ "github.com/sergi/go-diff/diffmatchpatch"
	_ "github.com/stretchr/testify/assert"
	_ "github.com/xeipuuv/gojsonschema"
)

func main() {
	if err := cli.Execute(); err != nil {
		os.Exit(1)
	}
}
</file>
<file path="internal/backup/backup.go">
package backup

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/diogenes/omo-profiler/internal/config"
)

// BackupInfo contains information about a backup file
type BackupInfo struct {
	Path      string
	Timestamp time.Time
	Name      string // filename without path
}

// Create creates a timestamped backup of the config file
// Returns the backup path or error
func Create(configPath string) (string, error) {
	// Check if file exists
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		return "", fmt.Errorf("config file does not exist: %s", configPath)
	}

	// Read original
	data, err := os.ReadFile(configPath)
	if err != nil {
		return "", fmt.Errorf("failed to read config: %w", err)
	}

	// Generate backup filename with timestamp
	timestamp := time.Now().Format("2006-01-02-150405")
	backupName := fmt.Sprintf("oh-my-opencode.json.bak.%s", timestamp)
	backupPath := filepath.Join(config.ConfigDir(), backupName)

	// Write backup
	if err := os.WriteFile(backupPath, data, 0644); err != nil {
		return "", fmt.Errorf("failed to write backup: %w", err)
	}

	return backupPath, nil
}

// List returns all backups sorted by timestamp (most recent first)
func List() ([]BackupInfo, error) {
	dir := config.ConfigDir()
	entries, err := os.ReadDir(dir)
	if err != nil {
		if os.IsNotExist(err) {
			return []BackupInfo{}, nil
		}
		return nil, err
	}

	var backups []BackupInfo
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		if !strings.HasPrefix(name, "oh-my-opencode.json.bak.") {
			continue
		}

		// Parse timestamp from filename
		parts := strings.Split(name, ".bak.")
		if len(parts) != 2 {
			continue
		}
		ts, err := time.Parse("2006-01-02-150405", parts[1])
		if err != nil {
			continue
		}

		backups = append(backups, BackupInfo{
			Path:      filepath.Join(dir, name),
			Timestamp: ts,
			Name:      name,
		})
	}

	// Sort by timestamp descending (most recent first)
	sort.Slice(backups, func(i, j int) bool {
		return backups[i].Timestamp.After(backups[j].Timestamp)
	})

	return backups, nil
}

// Restore restores a backup to the config file
func Restore(backupPath string) error {
	// Read backup
	data, err := os.ReadFile(backupPath)
	if err != nil {
		return fmt.Errorf("failed to read backup: %w", err)
	}

	// Write to config
	configPath := config.ConfigFile()
	if err := os.WriteFile(configPath, data, 0644); err != nil {
		return fmt.Errorf("failed to restore config: %w", err)
	}

	return nil
}

// Clean removes old backups, keeping only the N most recent
func Clean(keepLast int) error {
	backups, err := List()
	if err != nil {
		return err
	}

	if len(backups) <= keepLast {
		return nil
	}

	// Remove backups beyond keepLast
	for i := keepLast; i < len(backups); i++ {
		if err := os.Remove(backups[i].Path); err != nil {
			return fmt.Errorf("failed to remove backup %s: %w", backups[i].Name, err)
		}
	}

	return nil
}
</file>
<file path="internal/backup/backup_test.go">
package backup

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/diogenes/omo-profiler/internal/config"
)

func setupTestDir(t *testing.T) string {
	t.Helper()
	tmpDir := t.TempDir()
	config.SetBaseDir(tmpDir)
	t.Cleanup(config.ResetBaseDir)

	// Create config directory
	if err := os.MkdirAll(config.ConfigDir(), 0755); err != nil {
		t.Fatalf("failed to create config dir: %v", err)
	}
	return tmpDir
}

func TestCreate(t *testing.T) {
	setupTestDir(t)

	// Create a test config file
	configPath := config.ConfigFile()
	testContent := []byte(`{"test": "data"}`)
	if err := os.WriteFile(configPath, testContent, 0644); err != nil {
		t.Fatalf("failed to write test config: %v", err)
	}

	// Create backup
	backupPath, err := Create(configPath)
	if err != nil {
		t.Fatalf("Create() error = %v", err)
	}

	// Verify backup file exists
	if _, err := os.Stat(backupPath); os.IsNotExist(err) {
		t.Errorf("backup file does not exist: %s", backupPath)
	}

	// Verify backup content matches original
	backupContent, err := os.ReadFile(backupPath)
	if err != nil {
		t.Fatalf("failed to read backup: %v", err)
	}
	if string(backupContent) != string(testContent) {
		t.Errorf("backup content = %q, want %q", backupContent, testContent)
	}

	// Verify filename format
	filename := filepath.Base(backupPath)
	if len(filename) < len("oh-my-opencode.json.bak.2006-01-02-150405") {
		t.Errorf("backup filename too short: %s", filename)
	}
	if filename[:24] != "oh-my-opencode.json.bak." {
		t.Errorf("backup filename prefix wrong: %s", filename)
	}
}

func TestCreate_SourceNotExists(t *testing.T) {
	setupTestDir(t)

	_, err := Create("/nonexistent/path/config.json")
	if err == nil {
		t.Error("Create() should fail for nonexistent source")
	}
}

func TestList_Empty(t *testing.T) {
	setupTestDir(t)

	backups, err := List()
	if err != nil {
		t.Fatalf("List() error = %v", err)
	}
	if len(backups) != 0 {
		t.Errorf("List() returned %d backups, want 0", len(backups))
	}
}

func TestList_SortsByDateDescending(t *testing.T) {
	setupTestDir(t)
	dir := config.ConfigDir()

	// Create backups with different timestamps
	timestamps := []string{
		"2025-01-15-100000",
		"2025-01-16-120000",
		"2025-01-14-080000",
	}
	for _, ts := range timestamps {
		name := "oh-my-opencode.json.bak." + ts
		path := filepath.Join(dir, name)
		if err := os.WriteFile(path, []byte("{}"), 0644); err != nil {
			t.Fatalf("failed to create test backup: %v", err)
		}
	}

	backups, err := List()
	if err != nil {
		t.Fatalf("List() error = %v", err)
	}

	if len(backups) != 3 {
		t.Fatalf("List() returned %d backups, want 3", len(backups))
	}

	// Should be sorted descending (most recent first)
	expectedOrder := []string{
		"oh-my-opencode.json.bak.2025-01-16-120000",
		"oh-my-opencode.json.bak.2025-01-15-100000",
		"oh-my-opencode.json.bak.2025-01-14-080000",
	}
	for i, backup := range backups {
		if backup.Name != expectedOrder[i] {
			t.Errorf("backups[%d].Name = %s, want %s", i, backup.Name, expectedOrder[i])
		}
	}
}

func TestList_IgnoresOtherFiles(t *testing.T) {
	setupTestDir(t)
	dir := config.ConfigDir()

	// Create a valid backup
	validName := "oh-my-opencode.json.bak.2025-01-16-120000"
	if err := os.WriteFile(filepath.Join(dir, validName), []byte("{}"), 0644); err != nil {
		t.Fatalf("failed to create test backup: %v", err)
	}

	// Create files that should be ignored
	ignoredFiles := []string{
		"oh-my-opencode.json",         // main config
		"other-file.bak.2025-01-16",   // different prefix
		"oh-my-opencode.json.bak.bad", // bad timestamp
	}
	for _, name := range ignoredFiles {
		if err := os.WriteFile(filepath.Join(dir, name), []byte("{}"), 0644); err != nil {
			t.Fatalf("failed to create test file: %v", err)
		}
	}

	backups, err := List()
	if err != nil {
		t.Fatalf("List() error = %v", err)
	}

	if len(backups) != 1 {
		t.Errorf("List() returned %d backups, want 1", len(backups))
	}
	if len(backups) > 0 && backups[0].Name != validName {
		t.Errorf("backups[0].Name = %s, want %s", backups[0].Name, validName)
	}
}

func TestRestore(t *testing.T) {
	setupTestDir(t)
	dir := config.ConfigDir()

	// Create a backup file
	backupContent := []byte(`{"restored": true}`)
	backupPath := filepath.Join(dir, "oh-my-opencode.json.bak.2025-01-16-120000")
	if err := os.WriteFile(backupPath, backupContent, 0644); err != nil {
		t.Fatalf("failed to create backup: %v", err)
	}

	// Create original config with different content
	configPath := config.ConfigFile()
	if err := os.WriteFile(configPath, []byte(`{"original": true}`), 0644); err != nil {
		t.Fatalf("failed to write config: %v", err)
	}

	// Restore
	if err := Restore(backupPath); err != nil {
		t.Fatalf("Restore() error = %v", err)
	}

	// Verify config was restored
	restoredContent, err := os.ReadFile(configPath)
	if err != nil {
		t.Fatalf("failed to read config: %v", err)
	}
	if string(restoredContent) != string(backupContent) {
		t.Errorf("restored content = %q, want %q", restoredContent, backupContent)
	}
}

func TestRestore_BackupNotExists(t *testing.T) {
	setupTestDir(t)

	err := Restore("/nonexistent/backup.json")
	if err == nil {
		t.Error("Restore() should fail for nonexistent backup")
	}
}

func TestClean(t *testing.T) {
	setupTestDir(t)
	dir := config.ConfigDir()

	// Create 7 backups
	timestamps := []string{
		"2025-01-10-100000",
		"2025-01-11-100000",
		"2025-01-12-100000",
		"2025-01-13-100000",
		"2025-01-14-100000",
		"2025-01-15-100000",
		"2025-01-16-100000",
	}
	for _, ts := range timestamps {
		name := "oh-my-opencode.json.bak." + ts
		if err := os.WriteFile(filepath.Join(dir, name), []byte("{}"), 0644); err != nil {
			t.Fatalf("failed to create backup: %v", err)
		}
	}

	// Clean keeping only 5
	if err := Clean(5); err != nil {
		t.Fatalf("Clean() error = %v", err)
	}

	backups, err := List()
	if err != nil {
		t.Fatalf("List() error = %v", err)
	}

	if len(backups) != 5 {
		t.Errorf("after Clean(5), got %d backups, want 5", len(backups))
	}

	// Verify oldest backups were removed
	for _, backup := range backups {
		ts := backup.Timestamp
		if ts.Before(time.Date(2025, 1, 12, 10, 0, 0, 0, time.UTC)) {
			t.Errorf("old backup should have been removed: %s", backup.Name)
		}
	}
}

func TestClean_FewerThanKeep(t *testing.T) {
	setupTestDir(t)
	dir := config.ConfigDir()

	// Create only 2 backups
	timestamps := []string{
		"2025-01-15-100000",
		"2025-01-16-100000",
	}
	for _, ts := range timestamps {
		name := "oh-my-opencode.json.bak." + ts
		if err := os.WriteFile(filepath.Join(dir, name), []byte("{}"), 0644); err != nil {
			t.Fatalf("failed to create backup: %v", err)
		}
	}

	// Clean keeping 5 (more than we have)
	if err := Clean(5); err != nil {
		t.Fatalf("Clean() error = %v", err)
	}

	backups, err := List()
	if err != nil {
		t.Fatalf("List() error = %v", err)
	}

	if len(backups) != 2 {
		t.Errorf("after Clean(5) with 2 backups, got %d, want 2", len(backups))
	}
}
</file>
<file path="internal/cli/cmd/current.go">
package cmd

import (
	"fmt"
	"os"

	"github.com/diogenes/omo-profiler/internal/profile"
	"github.com/spf13/cobra"
)

var CurrentCmd = &cobra.Command{
	Use:   "current",
	Short: "Show the name of the active profile",
	Long:  `Displays the name of the currently active oh-my-opencode profile.`,
	Run: func(cmd *cobra.Command, args []string) {
		active, err := profile.GetActive()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
			os.Exit(1)
		}

		if !active.Exists {
			fmt.Println("(none)")
			os.Exit(1)
		}

		if active.IsOrphan {
			fmt.Println("(custom - unsaved)")
			os.Exit(0)
		}

		fmt.Println(active.ProfileName)
		os.Exit(0)
	},
}
</file>
<file path="internal/cli/cmd/export.go">
package cmd

import (
	"encoding/json"
	"fmt"
	"os"

	"github.com/diogenes/omo-profiler/internal/profile"
	"github.com/spf13/cobra"
)

var exportForce bool

var ExportCmd = &cobra.Command{
	Use:   "export <name> <path>",
	Short: "Export a profile to a file",
	Long:  `Exports the specified profile to a JSON file at the given path.`,
	Args:  cobra.ExactArgs(2),
	Run: func(cmd *cobra.Command, args []string) {
		name := args[0]
		path := args[1]

		if !profile.Exists(name) {
			fmt.Fprintf(os.Stderr, "Error: profile not found: %s\n", name)
			os.Exit(1)
		}

		if !exportForce {
			if _, err := os.Stat(path); err == nil {
				fmt.Fprintf(os.Stderr, "Error: destination file already exists: %s. Use --force to overwrite\n", path)
				os.Exit(1)
			}
		}

		p, err := profile.Load(name)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error: failed to load profile: %v\n", err)
			os.Exit(1)
		}

		data, err := json.MarshalIndent(p.Config, "", "  ")
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error: failed to marshal profile: %v\n", err)
			os.Exit(1)
		}

		if err := os.WriteFile(path, data, 0644); err != nil {
			fmt.Fprintf(os.Stderr, "Error: failed to write file: %v\n", err)
			os.Exit(1)
		}

		fmt.Printf("Exported profile \"%s\" to %s\n", name, path)
		os.Exit(0)
	},
}

func init() {
	ExportCmd.Flags().BoolVarP(&exportForce, "force", "f", false, "Overwrite destination if it exists")
}
</file>
<file path="internal/cli/cmd/import.go">
package cmd

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/diogenes/omo-profiler/internal/config"
	"github.com/diogenes/omo-profiler/internal/profile"
	"github.com/diogenes/omo-profiler/internal/schema"
	"github.com/spf13/cobra"
)

var importName string

var ImportCmd = &cobra.Command{
	Use:   "import <path>",
	Short: "Import a profile from a JSON file",
	Long:  `Imports a profile from a JSON file. The file must conform to the oh-my-opencode config schema.`,
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		sourcePath := args[0]

		data, err := os.ReadFile(sourcePath)
		if err != nil {
			if os.IsNotExist(err) {
				fmt.Fprintf(os.Stderr, "Error: file not found: %s\n", sourcePath)
			} else {
				fmt.Fprintf(os.Stderr, "Error: %v\n", err)
			}
			os.Exit(1)
		}

		var cfg config.Config
		if err := json.Unmarshal(data, &cfg); err != nil {
			fmt.Fprintf(os.Stderr, "Error: invalid JSON: %v\n", err)
			os.Exit(1)
		}

		validator, err := schema.NewValidator()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error: failed to create validator: %v\n", err)
			os.Exit(1)
		}

		validationErrors, err := validator.ValidateJSON(data)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error: validation failed: %v\n", err)
			os.Exit(2)
		}
		if len(validationErrors) > 0 {
			fmt.Fprintln(os.Stderr, "Error: validation failed:")
			for _, ve := range validationErrors {
				fmt.Fprintf(os.Stderr, "  - %s: %s\n", ve.Path, ve.Message)
			}
			os.Exit(2)
		}

		var originalName string
		var profileName string

		if importName != "" {
			originalName = importName
			profileName = profile.SanitizeName(importName)
		} else {
			filename := filepath.Base(sourcePath)
			originalName = strings.TrimSuffix(filename, ".json")
			profileName = profile.SanitizeName(originalName)
		}

		if profileName == "" {
			fmt.Fprintf(os.Stderr, "Error: cannot derive valid profile name from filename %q. Use --name <name> to specify.\n", originalName)
			os.Exit(1)
		}

		baseName := profileName
		hadCollision := false
		suffix := 1
		for profile.Exists(profileName) {
			hadCollision = true
			profileName = fmt.Sprintf("%s-%d", baseName, suffix)
			suffix++
		}

		p := &profile.Profile{
			Name:   profileName,
			Config: cfg,
		}

		if err := profile.Save(p); err != nil {
			fmt.Fprintf(os.Stderr, "Error: failed to save profile: %v\n", err)
			os.Exit(1)
		}

		if hadCollision {
			fmt.Printf("Profile %q exists, imported as %q\n", baseName, profileName)
		} else {
			fmt.Printf("Imported profile: %s\n", profileName)
		}
		os.Exit(0)
	},
}

func init() {
	ImportCmd.Flags().StringVarP(&importName, "name", "n", "", "Name for the imported profile")
}
</file>
<file path="internal/cli/cmd/list.go">
package cmd

import (
	"fmt"

	"github.com/diogenes/omo-profiler/internal/profile"
	"github.com/spf13/cobra"
)

var ListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all profiles",
	Long:  `Lists all available profiles. The active profile is marked with an asterisk (*).`,
	RunE: func(cmd *cobra.Command, args []string) error {
		profiles, err := profile.List()
		if err != nil {
			return fmt.Errorf("failed to list profiles: %w", err)
		}

		if len(profiles) == 0 {
			fmt.Println("(No profiles found)")
			return nil
		}

		active, err := profile.GetActive()
		if err != nil {
			return fmt.Errorf("failed to get active profile: %w", err)
		}

		activeProfileName := ""
		if active.Exists && !active.IsOrphan {
			activeProfileName = active.ProfileName
		}

		for _, name := range profiles {
			if name == activeProfileName {
				fmt.Printf("* %s (active)\n", name)
			} else {
				fmt.Printf("  %s\n", name)
			}
		}

		return nil
	},
}
</file>
<file path="internal/cli/cmd/switch.go">
package cmd

import (
	"fmt"
	"os"

	"github.com/diogenes/omo-profiler/internal/backup"
	"github.com/diogenes/omo-profiler/internal/config"
	"github.com/diogenes/omo-profiler/internal/profile"
	"github.com/spf13/cobra"
)

var SwitchCmd = &cobra.Command{
	Use:   "switch <name>",
	Short: "Activate a profile",
	Long:  `Switches to the specified profile by copying it to oh-my-opencode.json. Creates a timestamped backup of the current config before switching.`,
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		name := args[0]

		if !profile.Exists(name) {
			fmt.Fprintf(os.Stderr, "Error: profile not found: %s\n", name)
			os.Exit(1)
		}

		configPath := config.ConfigFile()
		if _, err := os.Stat(configPath); err == nil {
			_, err := backup.Create(configPath)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error: failed to create backup: %v\n", err)
				os.Exit(1)
			}
		}

		if err := profile.SetActive(name); err != nil {
			fmt.Fprintf(os.Stderr, "Error: failed to switch profile: %v\n", err)
			os.Exit(1)
		}

		fmt.Printf("Switched to profile: %s\n", name)
		os.Exit(0)
	},
}
</file>
<file path="internal/cli/root.go">
package cli

import (
	"fmt"
	"os"

	"github.com/diogenes/omo-profiler/internal/cli/cmd"
	"github.com/diogenes/omo-profiler/internal/tui"
	"github.com/spf13/cobra"
)

var (
	version = "0.1.0"
)

var rootCmd = &cobra.Command{
	Use:     "omo-profiler",
	Short:   "TUI profile manager for oh-my-opencode",
	Long:    `omo-profiler is a TUI application for managing oh-my-opencode configuration profiles.`,
	Version: version,
	Run: func(cmd *cobra.Command, args []string) {
		if err := tui.Run(); err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
			os.Exit(1)
		}
	},
}

// Execute runs the root command
func Execute() error {
	return rootCmd.Execute()
}

func init() {
	rootCmd.AddCommand(cmd.ListCmd)
	rootCmd.AddCommand(cmd.CurrentCmd)
	rootCmd.AddCommand(cmd.ExportCmd)
	rootCmd.AddCommand(cmd.SwitchCmd)
	rootCmd.AddCommand(cmd.ImportCmd)
}
</file>
<file path="internal/config/paths.go">
package config

import (
	"os"
	"path/filepath"
)

var baseDir string // empty = use os.UserHomeDir()

// SetBaseDir sets a custom base directory (for testing)
func SetBaseDir(path string) { baseDir = path }

// ResetBaseDir resets to using real home directory
func ResetBaseDir() { baseDir = "" }

// ConfigDir returns ~/.config/opencode/
func ConfigDir() string {
	if baseDir != "" {
		return filepath.Join(baseDir, ".config", "opencode")
	}
	home, _ := os.UserHomeDir()
	return filepath.Join(home, ".config", "opencode")
}

// ProfilesDir returns ~/.config/opencode/profiles/
func ProfilesDir() string {
	return filepath.Join(ConfigDir(), "profiles")
}

// ConfigFile returns ~/.config/opencode/oh-my-opencode.json
func ConfigFile() string {
	return filepath.Join(ConfigDir(), "oh-my-opencode.json")
}

// EnsureDirs creates config and profiles directories if they don't exist
func EnsureDirs() error {
	if err := os.MkdirAll(ConfigDir(), 0755); err != nil {
		return err
	}
	return os.MkdirAll(ProfilesDir(), 0755)
}

// DefaultSchema is the schema URL to add when creating new profiles
const DefaultSchema = "https://raw.githubusercontent.com/code-yeongyu/oh-my-opencode/master/assets/oh-my-opencode.schema.json"
</file>
<file path="internal/config/paths_test.go">
package config

import (
	"os"
	"path/filepath"
	"testing"
)

func TestSetBaseDir(t *testing.T) {
	// Save and restore original
	defer ResetBaseDir()

	tmpDir := t.TempDir()
	SetBaseDir(tmpDir)

	expected := filepath.Join(tmpDir, ".config", "opencode")
	if got := ConfigDir(); got != expected {
		t.Errorf("ConfigDir() = %s, want %s", got, expected)
	}
}

func TestResetBaseDir(t *testing.T) {
	tmpDir := t.TempDir()
	SetBaseDir(tmpDir)
	ResetBaseDir()

	// After reset, should use real home
	home, _ := os.UserHomeDir()
	expected := filepath.Join(home, ".config", "opencode")
	if got := ConfigDir(); got != expected {
		t.Errorf("ConfigDir() = %s, want %s", got, expected)
	}
}

func TestConfigDir(t *testing.T) {
	defer ResetBaseDir()

	tmpDir := t.TempDir()
	SetBaseDir(tmpDir)

	got := ConfigDir()
	expected := filepath.Join(tmpDir, ".config", "opencode")
	if got != expected {
		t.Errorf("ConfigDir() = %s, want %s", got, expected)
	}
}

func TestProfilesDir(t *testing.T) {
	defer ResetBaseDir()

	tmpDir := t.TempDir()
	SetBaseDir(tmpDir)

	got := ProfilesDir()
	expected := filepath.Join(tmpDir, ".config", "opencode", "profiles")
	if got != expected {
		t.Errorf("ProfilesDir() = %s, want %s", got, expected)
	}
}

func TestConfigFile(t *testing.T) {
	defer ResetBaseDir()

	tmpDir := t.TempDir()
	SetBaseDir(tmpDir)

	got := ConfigFile()
	expected := filepath.Join(tmpDir, ".config", "opencode", "oh-my-opencode.json")
	if got != expected {
		t.Errorf("ConfigFile() = %s, want %s", got, expected)
	}
}

func TestEnsureDirs(t *testing.T) {
	defer ResetBaseDir()

	tmpDir := t.TempDir()
	SetBaseDir(tmpDir)

	// Dirs should not exist initially
	configDir := ConfigDir()
	profilesDir := ProfilesDir()

	if _, err := os.Stat(configDir); !os.IsNotExist(err) {
		t.Fatalf("configDir should not exist before EnsureDirs")
	}

	// Call EnsureDirs
	if err := EnsureDirs(); err != nil {
		t.Fatalf("EnsureDirs() failed: %v", err)
	}

	// Both should exist now
	info, err := os.Stat(configDir)
	if err != nil {
		t.Errorf("configDir should exist after EnsureDirs: %v", err)
	}
	if !info.IsDir() {
		t.Errorf("configDir should be a directory")
	}

	info, err = os.Stat(profilesDir)
	if err != nil {
		t.Errorf("profilesDir should exist after EnsureDirs: %v", err)
	}
	if !info.IsDir() {
		t.Errorf("profilesDir should be a directory")
	}

	// Calling EnsureDirs again should be idempotent
	if err := EnsureDirs(); err != nil {
		t.Errorf("EnsureDirs() should be idempotent: %v", err)
	}
}

func TestDefaultSchema(t *testing.T) {
	expected := "https://raw.githubusercontent.com/code-yeongyu/oh-my-opencode/master/assets/oh-my-opencode.schema.json"
	if DefaultSchema != expected {
		t.Errorf("DefaultSchema = %s, want %s", DefaultSchema, expected)
	}
}
</file>
<file path="internal/config/types.go">
package config

import "encoding/json"

// Config is the root configuration struct
type Config struct {
	Schema           string                     `json:"$schema,omitempty"`
	DisabledMCPs     []string                   `json:"disabled_mcps,omitempty"`
	DisabledAgents   []string                   `json:"disabled_agents,omitempty"`
	DisabledSkills   []string                   `json:"disabled_skills,omitempty"`
	DisabledHooks    []string                   `json:"disabled_hooks,omitempty"`
	DisabledCommands []string                   `json:"disabled_commands,omitempty"`
	Agents           map[string]*AgentConfig    `json:"agents,omitempty"`
	Categories       map[string]*CategoryConfig `json:"categories,omitempty"`
	ClaudeCode       *ClaudeCodeConfig          `json:"claude_code,omitempty"`
	SisyphusAgent    *SisyphusAgentConfig       `json:"sisyphus_agent,omitempty"`
	CommentChecker   *CommentCheckerConfig      `json:"comment_checker,omitempty"`
	Experimental     *ExperimentalConfig        `json:"experimental,omitempty"`
	AutoUpdate       *bool                      `json:"auto_update,omitempty"`
	Skills           json.RawMessage            `json:"skills,omitempty"`
	RalphLoop        *RalphLoopConfig           `json:"ralph_loop,omitempty"`
	BackgroundTask   *BackgroundTaskConfig      `json:"background_task,omitempty"`
	Notification     *NotificationConfig        `json:"notification,omitempty"`
	GitMaster        *GitMasterConfig           `json:"git_master,omitempty"`
}

// AgentConfig has 14 optional fields
type AgentConfig struct {
	Model        string            `json:"model,omitempty"`
	Variant      string            `json:"variant,omitempty"`
	Category     string            `json:"category,omitempty"`
	Skills       []string          `json:"skills,omitempty"`
	Temperature  *float64          `json:"temperature,omitempty"`
	TopP         *float64          `json:"top_p,omitempty"`
	Prompt       string            `json:"prompt,omitempty"`
	PromptAppend string            `json:"prompt_append,omitempty"`
	Tools        map[string]bool   `json:"tools,omitempty"`
	Disable      *bool             `json:"disable,omitempty"`
	Description  string            `json:"description,omitempty"`
	Mode         string            `json:"mode,omitempty"`
	Color        string            `json:"color,omitempty"`
	Permission   *PermissionConfig `json:"permission,omitempty"`
}

// PermissionConfig - bash is interface{} to preserve string OR object
type PermissionConfig struct {
	Edit              string      `json:"edit,omitempty"`
	Bash              interface{} `json:"bash,omitempty"`
	Webfetch          string      `json:"webfetch,omitempty"`
	DoomLoop          string      `json:"doom_loop,omitempty"`
	ExternalDirectory string      `json:"external_directory,omitempty"`
}

// CategoryConfig
type CategoryConfig struct {
	Model           string          `json:"model"`
	Variant         string          `json:"variant,omitempty"`
	Temperature     *float64        `json:"temperature,omitempty"`
	TopP            *float64        `json:"top_p,omitempty"`
	MaxTokens       *float64        `json:"maxTokens,omitempty"`
	Thinking        *ThinkingConfig `json:"thinking,omitempty"`
	ReasoningEffort string          `json:"reasoningEffort,omitempty"`
	TextVerbosity   string          `json:"textVerbosity,omitempty"`
	Tools           map[string]bool `json:"tools,omitempty"`
	PromptAppend    string          `json:"prompt_append,omitempty"`
}

// ThinkingConfig
type ThinkingConfig struct {
	Type         string   `json:"type"`
	BudgetTokens *float64 `json:"budgetTokens,omitempty"`
}

// ClaudeCodeConfig
type ClaudeCodeConfig struct {
	MCP             *bool           `json:"mcp,omitempty"`
	Commands        *bool           `json:"commands,omitempty"`
	Skills          *bool           `json:"skills,omitempty"`
	Agents          *bool           `json:"agents,omitempty"`
	Hooks           *bool           `json:"hooks,omitempty"`
	Plugins         *bool           `json:"plugins,omitempty"`
	PluginsOverride map[string]bool `json:"plugins_override,omitempty"`
}

// SisyphusAgentConfig
type SisyphusAgentConfig struct {
	Disabled              *bool `json:"disabled,omitempty"`
	DefaultBuilderEnabled *bool `json:"default_builder_enabled,omitempty"`
	PlannerEnabled        *bool `json:"planner_enabled,omitempty"`
	ReplacePlan           *bool `json:"replace_plan,omitempty"`
}

// ExperimentalConfig
type ExperimentalConfig struct {
	AggressiveTruncation          *bool                        `json:"aggressive_truncation,omitempty"`
	AutoResume                    *bool                        `json:"auto_resume,omitempty"`
	PreemptiveCompaction          *bool                        `json:"preemptive_compaction,omitempty"`
	PreemptiveCompactionThreshold *float64                     `json:"preemptive_compaction_threshold,omitempty"`
	TruncateAllToolOutputs        *bool                        `json:"truncate_all_tool_outputs,omitempty"`
	DynamicContextPruning         *DynamicContextPruningConfig `json:"dynamic_context_pruning,omitempty"`
	DcpForCompaction              *bool                        `json:"dcp_for_compaction,omitempty"`
}

// DynamicContextPruningConfig
type DynamicContextPruningConfig struct {
	Enabled        *bool                 `json:"enabled,omitempty"`
	Notification   string                `json:"notification,omitempty"`
	TurnProtection *TurnProtectionConfig `json:"turn_protection,omitempty"`
	ProtectedTools []string              `json:"protected_tools,omitempty"`
	Strategies     *StrategiesConfig     `json:"strategies,omitempty"`
}

// TurnProtectionConfig
type TurnProtectionConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
	Turns   *int  `json:"turns,omitempty"`
}

// StrategiesConfig
type StrategiesConfig struct {
	Deduplication   *DeduplicationConfig   `json:"deduplication,omitempty"`
	SupersedeWrites *SupersedeWritesConfig `json:"supersede_writes,omitempty"`
	PurgeErrors     *PurgeErrorsConfig     `json:"purge_errors,omitempty"`
}

// DeduplicationConfig
type DeduplicationConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// SupersedeWritesConfig
type SupersedeWritesConfig struct {
	Enabled    *bool `json:"enabled,omitempty"`
	Aggressive *bool `json:"aggressive,omitempty"`
}

// PurgeErrorsConfig
type PurgeErrorsConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
	Turns   *int  `json:"turns,omitempty"`
}

// RalphLoopConfig
type RalphLoopConfig struct {
	Enabled              *bool  `json:"enabled,omitempty"`
	DefaultMaxIterations *int   `json:"default_max_iterations,omitempty"`
	StateDir             string `json:"state_dir,omitempty"`
}

// BackgroundTaskConfig
type BackgroundTaskConfig struct {
	DefaultConcurrency  *int           `json:"defaultConcurrency,omitempty"`
	ProviderConcurrency map[string]int `json:"providerConcurrency,omitempty"`
	ModelConcurrency    map[string]int `json:"modelConcurrency,omitempty"`
}

// NotificationConfig
type NotificationConfig struct {
	ForceEnable *bool `json:"force_enable,omitempty"`
}

// GitMasterConfig
type GitMasterConfig struct {
	CommitFooter        *bool `json:"commit_footer,omitempty"`
	IncludeCoAuthoredBy *bool `json:"include_co_authored_by,omitempty"`
}

// CommentCheckerConfig
type CommentCheckerConfig struct {
	CustomPrompt string `json:"custom_prompt,omitempty"`
}
</file>
<file path="internal/config/types_test.go">
package config

import (
	"encoding/json"
	"os"
	"reflect"
	"strings"
	"testing"
)

func TestRoundTrip(t *testing.T) {
	// Load valid-config.json
	data, err := os.ReadFile("../testdata/valid-config.json")
	if err != nil {
		t.Fatalf("failed to read valid-config.json: %v", err)
	}

	// Unmarshal into Config
	var cfg Config
	if err := json.Unmarshal(data, &cfg); err != nil {
		t.Fatalf("failed to unmarshal: %v", err)
	}

	// Marshal back to JSON
	marshaled, err := json.Marshal(&cfg)
	if err != nil {
		t.Fatalf("failed to marshal: %v", err)
	}

	// Compare normalized JSON (unmarshal both to map and compare)
	var original, roundtrip map[string]interface{}
	if err := json.Unmarshal(data, &original); err != nil {
		t.Fatalf("failed to unmarshal original: %v", err)
	}
	if err := json.Unmarshal(marshaled, &roundtrip); err != nil {
		t.Fatalf("failed to unmarshal roundtrip: %v", err)
	}

	if !reflect.DeepEqual(original, roundtrip) {
		origJSON, _ := json.MarshalIndent(original, "", "  ")
		rtJSON, _ := json.MarshalIndent(roundtrip, "", "  ")
		t.Errorf("round-trip mismatch:\noriginal:\n%s\n\nroundtrip:\n%s", origJSON, rtJSON)
	}
}

func TestMinimalConfig(t *testing.T) {
	data, err := os.ReadFile("../testdata/minimal-config.json")
	if err != nil {
		t.Fatalf("failed to read minimal-config.json: %v", err)
	}

	var cfg Config
	if err := json.Unmarshal(data, &cfg); err != nil {
		t.Fatalf("failed to unmarshal: %v", err)
	}

	// Verify build agent exists with correct model
	if cfg.Agents == nil {
		t.Fatal("agents is nil")
	}
	build, ok := cfg.Agents["build"]
	if !ok {
		t.Fatal("build agent not found")
	}
	if build.Model != "claude-sonnet-4-20250514" {
		t.Errorf("expected model claude-sonnet-4-20250514, got %s", build.Model)
	}
}

func TestSkillsPreservation_Array(t *testing.T) {
	// Test that json.RawMessage preserves array format
	jsonData := `{"skills": ["git-master", "playwright"]}`

	var cfg Config
	if err := json.Unmarshal([]byte(jsonData), &cfg); err != nil {
		t.Fatalf("failed to unmarshal: %v", err)
	}

	if cfg.Skills == nil {
		t.Fatal("skills is nil")
	}

	// Re-marshal and check format is preserved
	marshaled, err := json.Marshal(&cfg)
	if err != nil {
		t.Fatalf("failed to marshal: %v", err)
	}

	if !strings.Contains(string(marshaled), `"skills":["git-master","playwright"]`) {
		t.Errorf("skills array not preserved: %s", marshaled)
	}
}

func TestSkillsPreservation_Object(t *testing.T) {
	// Test that json.RawMessage preserves object format
	jsonData := `{"skills": {"git-master": true, "playwright": {"description": "browser automation"}}}`

	var cfg Config
	if err := json.Unmarshal([]byte(jsonData), &cfg); err != nil {
		t.Fatalf("failed to unmarshal: %v", err)
	}

	if cfg.Skills == nil {
		t.Fatal("skills is nil")
	}

	// Re-marshal and verify object structure is preserved
	marshaled, err := json.Marshal(&cfg)
	if err != nil {
		t.Fatalf("failed to marshal: %v", err)
	}

	// Should contain object format, not array
	if strings.Contains(string(marshaled), `"skills":[`) {
		t.Errorf("skills should be object, not array: %s", marshaled)
	}
	if !strings.Contains(string(marshaled), `"git-master":true`) {
		t.Errorf("skills object not preserved: %s", marshaled)
	}
}

func TestBashPermission_String(t *testing.T) {
	// Test bash permission as string
	jsonData := `{"agents": {"build": {"permission": {"bash": "allow"}}}}`

	var cfg Config
	if err := json.Unmarshal([]byte(jsonData), &cfg); err != nil {
		t.Fatalf("failed to unmarshal: %v", err)
	}

	perm := cfg.Agents["build"].Permission
	if perm == nil {
		t.Fatal("permission is nil")
	}

	bash, ok := perm.Bash.(string)
	if !ok {
		t.Fatalf("bash should be string, got %T", perm.Bash)
	}
	if bash != "allow" {
		t.Errorf("expected bash=allow, got %s", bash)
	}

	// Round-trip
	marshaled, err := json.Marshal(&cfg)
	if err != nil {
		t.Fatalf("failed to marshal: %v", err)
	}
	if !strings.Contains(string(marshaled), `"bash":"allow"`) {
		t.Errorf("bash string not preserved: %s", marshaled)
	}
}

func TestBashPermission_Object(t *testing.T) {
	// Test bash permission as object
	jsonData := `{"agents": {"build": {"permission": {"bash": {"git": "allow", "rm": "deny"}}}}}`

	var cfg Config
	if err := json.Unmarshal([]byte(jsonData), &cfg); err != nil {
		t.Fatalf("failed to unmarshal: %v", err)
	}

	perm := cfg.Agents["build"].Permission
	if perm == nil {
		t.Fatal("permission is nil")
	}

	bashObj, ok := perm.Bash.(map[string]interface{})
	if !ok {
		t.Fatalf("bash should be map, got %T", perm.Bash)
	}
	if bashObj["git"] != "allow" {
		t.Errorf("expected git=allow, got %v", bashObj["git"])
	}
	if bashObj["rm"] != "deny" {
		t.Errorf("expected rm=deny, got %v", bashObj["rm"])
	}

	// Round-trip
	marshaled, err := json.Marshal(&cfg)
	if err != nil {
		t.Fatalf("failed to marshal: %v", err)
	}
	if !strings.Contains(string(marshaled), `"git":"allow"`) {
		t.Errorf("bash object not preserved: %s", marshaled)
	}
}

func TestEmptyConfigMarshal(t *testing.T) {
	// Empty Config should marshal to {}
	cfg := Config{}

	marshaled, err := json.Marshal(&cfg)
	if err != nil {
		t.Fatalf("failed to marshal empty config: %v", err)
	}

	if string(marshaled) != "{}" {
		t.Errorf("empty config should marshal to {}, got: %s", marshaled)
	}
}

func TestOmitempty(t *testing.T) {
	// Config with only schema set should only have $schema in output
	cfg := Config{
		Schema: "https://example.com/schema.json",
	}

	marshaled, err := json.Marshal(&cfg)
	if err != nil {
		t.Fatalf("failed to marshal: %v", err)
	}

	// Should only contain $schema
	expected := `{"$schema":"https://example.com/schema.json"}`
	if string(marshaled) != expected {
		t.Errorf("expected %s, got %s", expected, marshaled)
	}
}
</file>
<file path="internal/diff/diff.go">
package diff

import (
	"strings"

	dmp "github.com/sergi/go-diff/diffmatchpatch"
)

// DiffType represents the type of difference for a line
type DiffType int

const (
	DiffEqual DiffType = iota
	DiffAdded
	DiffRemoved
)

// DiffLine represents a single line in the diff result
type DiffLine struct {
	Text    string
	Type    DiffType
	LineNum int
}

// DiffResult contains the side-by-side diff representation
type DiffResult struct {
	Left  []DiffLine
	Right []DiffLine
}

// ComputeDiff computes a line-based diff between two JSON byte slices
func ComputeDiff(json1, json2 []byte) (*DiffResult, error) {
	differ := dmp.New()

	text1 := string(json1)
	text2 := string(json2)

	chars1, chars2, lineArray := differ.DiffLinesToChars(text1, text2)
	diffs := differ.DiffMain(chars1, chars2, false)
	diffs = differ.DiffCharsToLines(diffs, lineArray)
	diffs = differ.DiffCleanupSemantic(diffs)

	return buildDiffResult(diffs), nil
}

// buildDiffResult converts dmp.Diff slices to DiffResult with side-by-side representation
func buildDiffResult(diffs []dmp.Diff) *DiffResult {
	result := &DiffResult{
		Left:  make([]DiffLine, 0),
		Right: make([]DiffLine, 0),
	}

	leftLineNum := 1
	rightLineNum := 1

	for _, d := range diffs {
		lines := splitLines(d.Text)

		switch d.Type {
		case dmp.DiffEqual:
			for _, line := range lines {
				result.Left = append(result.Left, DiffLine{
					Text:    line,
					Type:    DiffEqual,
					LineNum: leftLineNum,
				})
				result.Right = append(result.Right, DiffLine{
					Text:    line,
					Type:    DiffEqual,
					LineNum: rightLineNum,
				})
				leftLineNum++
				rightLineNum++
			}
		case dmp.DiffDelete:
			for _, line := range lines {
				result.Left = append(result.Left, DiffLine{
					Text:    line,
					Type:    DiffRemoved,
					LineNum: leftLineNum,
				})
				result.Right = append(result.Right, DiffLine{
					Text:    "",
					Type:    DiffRemoved,
					LineNum: 0,
				})
				leftLineNum++
			}
		case dmp.DiffInsert:
			for _, line := range lines {
				result.Left = append(result.Left, DiffLine{
					Text:    "",
					Type:    DiffAdded,
					LineNum: 0,
				})
				result.Right = append(result.Right, DiffLine{
					Text:    line,
					Type:    DiffAdded,
					LineNum: rightLineNum,
				})
				rightLineNum++
			}
		}
	}

	return result
}

// splitLines splits text into lines, handling trailing newlines properly
func splitLines(text string) []string {
	if text == "" {
		return nil
	}

	lines := strings.Split(text, "\n")

	if len(lines) > 0 && lines[len(lines)-1] == "" {
		lines = lines[:len(lines)-1]
	}

	return lines
}
</file>
<file path="internal/profile/active.go">
package profile

import (
	"bytes"
	"encoding/json"
	"os"

	"github.com/diogenes/omo-profiler/internal/config"
)

type ActiveConfig struct {
	Exists      bool
	Config      config.Config
	ProfileName string
	IsOrphan    bool
}

func GetActive() (*ActiveConfig, error) {
	configPath := config.ConfigFile()

	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		return &ActiveConfig{Exists: false}, nil
	}

	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, err
	}

	var cfg config.Config
	if err := json.Unmarshal(data, &cfg); err != nil {
		return nil, err
	}

	profiles, err := List()
	if err != nil {
		return nil, err
	}

	for _, name := range profiles {
		profile, err := Load(name)
		if err != nil {
			continue
		}
		if profile.MatchesConfig(&cfg) {
			return &ActiveConfig{
				Exists:      true,
				Config:      cfg,
				ProfileName: name,
				IsOrphan:    false,
			}, nil
		}
	}

	return &ActiveConfig{
		Exists:      true,
		Config:      cfg,
		ProfileName: "(custom)",
		IsOrphan:    true,
	}, nil
}

func SetActive(name string) error {
	profile, err := Load(name)
	if err != nil {
		return err
	}

	if err := config.EnsureDirs(); err != nil {
		return err
	}

	data, err := json.MarshalIndent(profile.Config, "", "  ")
	if err != nil {
		return err
	}

	return os.WriteFile(config.ConfigFile(), data, 0644)
}

func (p *Profile) MatchesConfig(cfg *config.Config) bool {
	pBytes, err1 := normalizeForComparison(&p.Config)
	cBytes, err2 := normalizeForComparison(cfg)

	if err1 != nil || err2 != nil {
		return false
	}

	return bytes.Equal(pBytes, cBytes)
}

func normalizeForComparison(cfg *config.Config) ([]byte, error) {
	cfgCopy := *cfg
	cfgCopy.Schema = ""

	return json.Marshal(cfgCopy)
}
</file>
<file path="internal/profile/active_test.go">
package profile

import (
	"encoding/json"
	"os"
	"testing"

	"github.com/diogenes/omo-profiler/internal/config"
)

func setupTestDir(t *testing.T) {
	t.Helper()
	tmpDir := t.TempDir()
	config.SetBaseDir(tmpDir)
	t.Cleanup(config.ResetBaseDir)
}

func TestGetActive_NoConfig(t *testing.T) {
	setupTestDir(t)
	if err := config.EnsureDirs(); err != nil {
		t.Fatalf("failed to create dirs: %v", err)
	}

	active, err := GetActive()
	if err != nil {
		t.Fatalf("GetActive failed: %v", err)
	}

	if active.Exists {
		t.Errorf("expected Exists=false when no config")
	}
}

func TestGetActive_MatchingProfile(t *testing.T) {
	setupTestDir(t)
	if err := config.EnsureDirs(); err != nil {
		t.Fatalf("failed to create dirs: %v", err)
	}

	// Create a profile
	testConfig := config.Config{
		Agents: map[string]*config.AgentConfig{
			"build": {Model: "test-model"},
		},
	}
	p := &Profile{Name: "dev", Config: testConfig}
	if err := Save(p); err != nil {
		t.Fatalf("failed to save profile: %v", err)
	}

	// Set it as active
	if err := SetActive("dev"); err != nil {
		t.Fatalf("failed to set active: %v", err)
	}

	// Get active
	active, err := GetActive()
	if err != nil {
		t.Fatalf("GetActive failed: %v", err)
	}

	if !active.Exists {
		t.Errorf("expected Exists=true")
	}
	if active.IsOrphan {
		t.Errorf("expected IsOrphan=false")
	}
	if active.ProfileName != "dev" {
		t.Errorf("expected ProfileName='dev', got '%s'", active.ProfileName)
	}
}

func TestGetActive_OrphanConfig(t *testing.T) {
	setupTestDir(t)
	if err := config.EnsureDirs(); err != nil {
		t.Fatalf("failed to create dirs: %v", err)
	}

	// Create a config file directly (not from a profile)
	orphanConfig := config.Config{
		Agents: map[string]*config.AgentConfig{
			"oracle": {Model: "custom-model"},
		},
	}
	data, _ := json.MarshalIndent(orphanConfig, "", "  ")
	if err := os.WriteFile(config.ConfigFile(), data, 0644); err != nil {
		t.Fatalf("failed to write config: %v", err)
	}

	// Get active
	active, err := GetActive()
	if err != nil {
		t.Fatalf("GetActive failed: %v", err)
	}

	if !active.Exists {
		t.Errorf("expected Exists=true")
	}
	if !active.IsOrphan {
		t.Errorf("expected IsOrphan=true")
	}
	if active.ProfileName != "(custom)" {
		t.Errorf("expected ProfileName='(custom)', got '%s'", active.ProfileName)
	}
}

func TestSetActive(t *testing.T) {
	setupTestDir(t)
	if err := config.EnsureDirs(); err != nil {
		t.Fatalf("failed to create dirs: %v", err)
	}

	// Create a profile
	testConfig := config.Config{
		Agents: map[string]*config.AgentConfig{
			"build": {Model: "my-model"},
		},
	}
	p := &Profile{Name: "production", Config: testConfig}
	if err := Save(p); err != nil {
		t.Fatalf("failed to save profile: %v", err)
	}

	// Set it active
	if err := SetActive("production"); err != nil {
		t.Fatalf("SetActive failed: %v", err)
	}

	// Verify config file exists and matches
	data, err := os.ReadFile(config.ConfigFile())
	if err != nil {
		t.Fatalf("failed to read config: %v", err)
	}

	var loaded config.Config
	if err := json.Unmarshal(data, &loaded); err != nil {
		t.Fatalf("failed to parse config: %v", err)
	}

	if loaded.Agents["build"].Model != "my-model" {
		t.Errorf("expected model 'my-model', got '%s'", loaded.Agents["build"].Model)
	}
}

func TestSetActive_NotFound(t *testing.T) {
	setupTestDir(t)
	if err := config.EnsureDirs(); err != nil {
		t.Fatalf("failed to create dirs: %v", err)
	}

	err := SetActive("nonexistent")
	if err == nil {
		t.Errorf("expected error for non-existent profile")
	}
}

func TestMatchesConfig_SchemaDifference(t *testing.T) {
	setupTestDir(t)
	if err := config.EnsureDirs(); err != nil {
		t.Fatalf("failed to create dirs: %v", err)
	}

	// Create a profile without schema
	cfg := config.Config{
		Agents: map[string]*config.AgentConfig{
			"build": {Model: "test"},
		},
	}
	p := &Profile{Name: "test", Config: cfg}

	// Config with schema should still match
	cfgWithSchema := cfg
	cfgWithSchema.Schema = "https://example.com/schema.json"

	if !p.MatchesConfig(&cfgWithSchema) {
		t.Errorf("configs should match (schema is ignored)")
	}
}

func TestMatchesProfile(t *testing.T) {
	setupTestDir(t)

	p := &Profile{
		Name: "test",
		Config: config.Config{
			Agents: map[string]*config.AgentConfig{
				"build": {Model: "model-a"},
			},
		},
	}

	// Matching config
	matching := config.Config{
		Agents: map[string]*config.AgentConfig{
			"build": {Model: "model-a"},
		},
	}

	if !p.MatchesConfig(&matching) {
		t.Errorf("expected configs to match")
	}

	// Non-matching config
	different := config.Config{
		Agents: map[string]*config.AgentConfig{
			"build": {Model: "model-b"},
		},
	}

	if p.MatchesConfig(&different) {
		t.Errorf("expected configs to not match")
	}
}

func TestNormalizeForComparison(t *testing.T) {
	// Test that $schema is removed
	cfg := &config.Config{
		Schema: "https://example.com/schema.json",
		Agents: map[string]*config.AgentConfig{
			"build": {Model: "test"},
		},
	}

	data, err := normalizeForComparison(cfg)
	if err != nil {
		t.Fatalf("normalizeForComparison failed: %v", err)
	}

	var result map[string]interface{}
	if err := json.Unmarshal(data, &result); err != nil {
		t.Fatalf("failed to unmarshal: %v", err)
	}

	if _, ok := result["$schema"]; ok {
		t.Errorf("$schema should be removed in normalized output")
	}
}
</file>
<file path="internal/profile/naming.go">
package profile

import (
	"errors"
	"regexp"
	"strings"
)

var validNameRegex = regexp.MustCompile(`^[a-zA-Z0-9_-]+$`)

var ErrInvalidName = errors.New("profile name must contain only letters, numbers, underscores, and hyphens")

var ErrEmptyName = errors.New("profile name cannot be empty")

func ValidateName(name string) error {
	if name == "" {
		return ErrEmptyName
	}
	if !validNameRegex.MatchString(name) {
		return ErrInvalidName
	}
	return nil
}

func SanitizeName(name string) string {
	re := regexp.MustCompile(`[^a-zA-Z0-9_-]`)
	sanitized := re.ReplaceAllString(name, "")
	sanitized = strings.Trim(sanitized, "-_")
	return sanitized
}
</file>
<file path="internal/profile/naming_test.go">
package profile

import "testing"

func TestValidateName(t *testing.T) {
	tests := []struct {
		name    string
		input   string
		wantErr bool
	}{
		{"valid simple", "myprofile", false},
		{"valid with dash", "my-profile", false},
		{"valid with underscore", "my_profile", false},
		{"valid with numbers", "profile123", false},
		{"valid mixed", "My-Profile_123", false},
		{"empty", "", true},
		{"with spaces", "my profile", true},
		{"with slash", "my/profile", true},
		{"with dots", "my.profile", true},
		{"with special chars", "my@profile!", true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ValidateName(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("ValidateName(%q) error = %v, wantErr %v", tt.input, err, tt.wantErr)
			}
		})
	}
}

func TestSanitizeName(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{"already valid", "myprofile", "myprofile"},
		{"with spaces", "my profile", "myprofile"},
		{"with dots", "my.profile.json", "myprofilejson"},
		{"with slashes", "path/to/profile", "pathtoprofile"},
		{"with special chars", "my@profile!", "myprofile"},
		{"leading dash", "-profile", "profile"},
		{"trailing underscore", "profile_", "profile"},
		{"mixed", "  --my.profile!!  ", "myprofile"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := SanitizeName(tt.input)
			if result != tt.expected {
				t.Errorf("SanitizeName(%q) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}
</file>
<file path="internal/profile/profile.go">
package profile

import (
	"encoding/json"
	"os"
	"path/filepath"
	"strings"

	"github.com/diogenes/omo-profiler/internal/config"
)

// Profile represents a saved configuration profile
type Profile struct {
	Name   string
	Config config.Config
	Path   string
}

// Load loads a profile by name from the profiles directory
func Load(name string) (*Profile, error) {
	path := filepath.Join(config.ProfilesDir(), name+".json")
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var cfg config.Config
	if err := json.Unmarshal(data, &cfg); err != nil {
		return nil, err
	}

	return &Profile{
		Name:   name,
		Config: cfg,
		Path:   path,
	}, nil
}

func Save(p *Profile) error {
	return p.Save()
}

func (p *Profile) Save() error {
	if err := config.EnsureDirs(); err != nil {
		return err
	}

	path := filepath.Join(config.ProfilesDir(), p.Name+".json")
	data, err := json.MarshalIndent(p.Config, "", "  ")
	if err != nil {
		return err
	}

	p.Path = path
	return os.WriteFile(path, data, 0644)
}

// Delete removes the profile file
func Delete(name string) error {
	path := filepath.Join(config.ProfilesDir(), name+".json")
	return os.Remove(path)
}

// List returns names of all profiles (without .json extension)
func List() ([]string, error) {
	dir := config.ProfilesDir()
	entries, err := os.ReadDir(dir)
	if err != nil {
		if os.IsNotExist(err) {
			return []string{}, nil
		}
		return nil, err
	}

	var names []string
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		if strings.HasSuffix(name, ".json") {
			names = append(names, strings.TrimSuffix(name, ".json"))
		}
	}
	return names, nil
}

// Exists checks if a profile exists
func Exists(name string) bool {
	path := filepath.Join(config.ProfilesDir(), name+".json")
	_, err := os.Stat(path)
	return err == nil
}
</file>
<file path="internal/profile/profile_test.go">
package profile

import (
	"encoding/json"
	"os"
	"path/filepath"
	"testing"

	"github.com/diogenes/omo-profiler/internal/config"
)

func setupTestEnv(t *testing.T) func() {
	t.Helper()
	tmpDir := t.TempDir()
	config.SetBaseDir(tmpDir)
	return func() {
		config.ResetBaseDir()
	}
}

func TestLoad(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	// Ensure directories exist
	if err := config.EnsureDirs(); err != nil {
		t.Fatalf("EnsureDirs failed: %v", err)
	}

	// Create a test profile
	cfg := config.Config{
		DisabledMCPs: []string{"test-mcp"},
	}
	data, _ := json.MarshalIndent(cfg, "", "  ")
	profilePath := filepath.Join(config.ProfilesDir(), "test-profile.json")
	if err := os.WriteFile(profilePath, data, 0644); err != nil {
		t.Fatalf("Failed to create test profile: %v", err)
	}

	// Test Load
	p, err := Load("test-profile")
	if err != nil {
		t.Fatalf("Load failed: %v", err)
	}

	if p.Name != "test-profile" {
		t.Errorf("Expected name 'test-profile', got '%s'", p.Name)
	}

	if len(p.Config.DisabledMCPs) != 1 || p.Config.DisabledMCPs[0] != "test-mcp" {
		t.Errorf("Config not loaded correctly")
	}
}

func TestLoadNonexistent(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	_, err := Load("nonexistent")
	if err == nil {
		t.Error("Expected error when loading nonexistent profile")
	}
}

func TestSave(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	p := &Profile{
		Name: "new-profile",
		Config: config.Config{
			DisabledAgents: []string{"agent1"},
		},
	}

	if err := Save(p); err != nil {
		t.Fatalf("Save failed: %v", err)
	}

	// Verify file was created
	expectedPath := filepath.Join(config.ProfilesDir(), "new-profile.json")
	if _, err := os.Stat(expectedPath); err != nil {
		t.Errorf("Profile file not created at %s", expectedPath)
	}

	// Verify content
	data, _ := os.ReadFile(expectedPath)
	var loaded config.Config
	json.Unmarshal(data, &loaded)

	if len(loaded.DisabledAgents) != 1 || loaded.DisabledAgents[0] != "agent1" {
		t.Error("Saved config doesn't match original")
	}
}

func TestDelete(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	if err := config.EnsureDirs(); err != nil {
		t.Fatalf("EnsureDirs failed: %v", err)
	}

	// Create a profile to delete
	profilePath := filepath.Join(config.ProfilesDir(), "to-delete.json")
	os.WriteFile(profilePath, []byte("{}"), 0644)

	if err := Delete("to-delete"); err != nil {
		t.Fatalf("Delete failed: %v", err)
	}

	if _, err := os.Stat(profilePath); !os.IsNotExist(err) {
		t.Error("Profile file should be deleted")
	}
}

func TestDeleteNonexistent(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	err := Delete("nonexistent")
	if err == nil {
		t.Error("Expected error when deleting nonexistent profile")
	}
}

func TestList(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	if err := config.EnsureDirs(); err != nil {
		t.Fatalf("EnsureDirs failed: %v", err)
	}

	// Create test profiles
	profilesDir := config.ProfilesDir()
	os.WriteFile(filepath.Join(profilesDir, "profile1.json"), []byte("{}"), 0644)
	os.WriteFile(filepath.Join(profilesDir, "profile2.json"), []byte("{}"), 0644)
	os.WriteFile(filepath.Join(profilesDir, "not-json.txt"), []byte("{}"), 0644)

	profiles, err := List()
	if err != nil {
		t.Fatalf("List failed: %v", err)
	}

	if len(profiles) != 2 {
		t.Errorf("Expected 2 profiles, got %d", len(profiles))
	}

	// Check that both are present (order may vary)
	found1, found2 := false, false
	for _, p := range profiles {
		if p == "profile1" {
			found1 = true
		}
		if p == "profile2" {
			found2 = true
		}
	}
	if !found1 || !found2 {
		t.Errorf("Expected profile1 and profile2, got %v", profiles)
	}
}

func TestListEmpty(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	// Don't create profiles directory - should return empty list
	profiles, err := List()
	if err != nil {
		t.Fatalf("List failed: %v", err)
	}

	if len(profiles) != 0 {
		t.Errorf("Expected 0 profiles, got %d", len(profiles))
	}
}

func TestExists(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	if err := config.EnsureDirs(); err != nil {
		t.Fatalf("EnsureDirs failed: %v", err)
	}

	// Create a profile
	profilePath := filepath.Join(config.ProfilesDir(), "exists-test.json")
	os.WriteFile(profilePath, []byte("{}"), 0644)

	if !Exists("exists-test") {
		t.Error("Expected profile to exist")
	}

	if Exists("nonexistent") {
		t.Error("Expected profile to not exist")
	}
}
</file>
<file path="internal/schema/schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://raw.githubusercontent.com/code-yeongyu/oh-my-opencode/master/assets/oh-my-opencode.schema.json",
  "title": "Oh My OpenCode Configuration",
  "description": "Configuration schema for oh-my-opencode plugin",
  "type": "object",
  "properties": {
    "$schema": {
      "type": "string"
    },
    "disabled_mcps": {
      "type": "array",
      "items": {
        "type": "string",
        "minLength": 1
      }
    },
    "disabled_agents": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "Sisyphus",
          "oracle",
          "librarian",
          "explore",
          "frontend-ui-ux-engineer",
          "document-writer",
          "multimodal-looker",
          "Metis (Plan Consultant)",
          "Momus (Plan Reviewer)",
          "orchestrator-sisyphus"
        ]
      }
    },
    "disabled_skills": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "playwright",
          "frontend-ui-ux",
          "git-master"
        ]
      }
    },
    "disabled_hooks": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "todo-continuation-enforcer",
          "context-window-monitor",
          "session-recovery",
          "session-notification",
          "comment-checker",
          "grep-output-truncator",
          "tool-output-truncator",
          "directory-agents-injector",
          "directory-readme-injector",
          "empty-task-response-detector",
          "think-mode",
          "anthropic-context-window-limit-recovery",
          "rules-injector",
          "background-notification",
          "auto-update-checker",
          "startup-toast",
          "keyword-detector",
          "agent-usage-reminder",
          "non-interactive-env",
          "interactive-bash-session",
          "empty-message-sanitizer",
          "thinking-block-validator",
          "ralph-loop",
          "preemptive-compaction",
          "compaction-context-injector",
          "claude-code-hooks",
          "auto-slash-command",
          "edit-error-recovery",
          "prometheus-md-only",
          "start-work",
          "sisyphus-orchestrator"
        ]
      }
    },
    "disabled_commands": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "init-deep",
          "start-work"
        ]
      }
    },
    "agents": {
      "type": "object",
      "properties": {
        "build": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "plan": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "Sisyphus": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "Sisyphus-Junior": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "OpenCode-Builder": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "Prometheus (Planner)": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "Metis (Plan Consultant)": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "Momus (Plan Reviewer)": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "oracle": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "librarian": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "explore": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "frontend-ui-ux-engineer": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "document-writer": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "multimodal-looker": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "orchestrator-sisyphus": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "categories": {
      "type": "object",
      "propertyNames": {
        "type": "string"
      },
      "additionalProperties": {
        "type": "object",
        "properties": {
          "model": {
            "type": "string"
          },
          "variant": {
            "type": "string"
          },
          "temperature": {
            "type": "number",
            "minimum": 0,
            "maximum": 2
          },
          "top_p": {
            "type": "number",
            "minimum": 0,
            "maximum": 1
          },
          "maxTokens": {
            "type": "number"
          },
          "thinking": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "enabled",
                  "disabled"
                ]
              },
              "budgetTokens": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          },
          "reasoningEffort": {
            "type": "string",
            "enum": [
              "low",
              "medium",
              "high"
            ]
          },
          "textVerbosity": {
            "type": "string",
            "enum": [
              "low",
              "medium",
              "high"
            ]
          },
          "tools": {
            "type": "object",
            "propertyNames": {
              "type": "string"
            },
            "additionalProperties": {
              "type": "boolean"
            }
          },
          "prompt_append": {
            "type": "string"
          }
        },
        "required": [
          "model"
        ]
      }
    },
    "claude_code": {
      "type": "object",
      "properties": {
        "mcp": {
          "type": "boolean"
        },
        "commands": {
          "type": "boolean"
        },
        "skills": {
          "type": "boolean"
        },
        "agents": {
          "type": "boolean"
        },
        "hooks": {
          "type": "boolean"
        },
        "plugins": {
          "type": "boolean"
        },
        "plugins_override": {
          "type": "object",
          "propertyNames": {
            "type": "string"
          },
          "additionalProperties": {
            "type": "boolean"
          }
        }
      }
    },
    "sisyphus_agent": {
      "type": "object",
      "properties": {
        "disabled": {
          "type": "boolean"
        },
        "default_builder_enabled": {
          "type": "boolean"
        },
        "planner_enabled": {
          "type": "boolean"
        },
        "replace_plan": {
          "type": "boolean"
        }
      }
    },
    "comment_checker": {
      "type": "object",
      "properties": {
        "custom_prompt": {
          "type": "string"
        }
      }
    },
    "experimental": {
      "type": "object",
      "properties": {
        "aggressive_truncation": {
          "type": "boolean"
        },
        "auto_resume": {
          "type": "boolean"
        },
        "preemptive_compaction": {
          "type": "boolean"
        },
        "preemptive_compaction_threshold": {
          "type": "number",
          "minimum": 0.5,
          "maximum": 0.95
        },
        "truncate_all_tool_outputs": {
          "type": "boolean"
        },
        "dynamic_context_pruning": {
          "type": "object",
          "properties": {
            "enabled": {
              "default": false,
              "type": "boolean"
            },
            "notification": {
              "default": "detailed",
              "type": "string",
              "enum": [
                "off",
                "minimal",
                "detailed"
              ]
            },
            "turn_protection": {
              "type": "object",
              "properties": {
                "enabled": {
                  "default": true,
                  "type": "boolean"
                },
                "turns": {
                  "default": 3,
                  "type": "number",
                  "minimum": 1,
                  "maximum": 10
                }
              }
            },
            "protected_tools": {
              "default": [
                "task",
                "todowrite",
                "todoread",
                "lsp_rename",
                "session_read",
                "session_write",
                "session_search"
              ],
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "strategies": {
              "type": "object",
              "properties": {
                "deduplication": {
                  "type": "object",
                  "properties": {
                    "enabled": {
                      "default": true,
                      "type": "boolean"
                    }
                  }
                },
                "supersede_writes": {
                  "type": "object",
                  "properties": {
                    "enabled": {
                      "default": true,
                      "type": "boolean"
                    },
                    "aggressive": {
                      "default": false,
                      "type": "boolean"
                    }
                  }
                },
                "purge_errors": {
                  "type": "object",
                  "properties": {
                    "enabled": {
                      "default": true,
                      "type": "boolean"
                    },
                    "turns": {
                      "default": 5,
                      "type": "number",
                      "minimum": 1,
                      "maximum": 20
                    }
                  }
                }
              }
            }
          }
        },
        "dcp_for_compaction": {
          "type": "boolean"
        }
      }
    },
    "auto_update": {
      "type": "boolean"
    },
    "skills": {
      "anyOf": [
        {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        {
          "allOf": [
            {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "anyOf": [
                  {
                    "type": "boolean"
                  },
                  {
                    "type": "object",
                    "properties": {
                      "description": {
                        "type": "string"
                      },
                      "template": {
                        "type": "string"
                      },
                      "from": {
                        "type": "string"
                      },
                      "model": {
                        "type": "string"
                      },
                      "agent": {
                        "type": "string"
                      },
                      "subtask": {
                        "type": "boolean"
                      },
                      "argument-hint": {
                        "type": "string"
                      },
                      "license": {
                        "type": "string"
                      },
                      "compatibility": {
                        "type": "string"
                      },
                      "metadata": {
                        "type": "object",
                        "propertyNames": {
                          "type": "string"
                        },
                        "additionalProperties": {}
                      },
                      "allowed-tools": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "disable": {
                        "type": "boolean"
                      }
                    }
                  }
                ]
              }
            },
            {
              "type": "object",
              "properties": {
                "sources": {
                  "type": "array",
                  "items": {
                    "anyOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "object",
                        "properties": {
                          "path": {
                            "type": "string"
                          },
                          "recursive": {
                            "type": "boolean"
                          },
                          "glob": {
                            "type": "string"
                          }
                        },
                        "required": [
                          "path"
                        ]
                      }
                    ]
                  }
                },
                "enable": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "disable": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          ]
        }
      ]
    },
    "ralph_loop": {
      "type": "object",
      "properties": {
        "enabled": {
          "default": false,
          "type": "boolean"
        },
        "default_max_iterations": {
          "default": 100,
          "type": "number",
          "minimum": 1,
          "maximum": 1000
        },
        "state_dir": {
          "type": "string"
        }
      }
    },
    "background_task": {
      "type": "object",
      "properties": {
        "defaultConcurrency": {
          "type": "number",
          "minimum": 1
        },
        "providerConcurrency": {
          "type": "object",
          "propertyNames": {
            "type": "string"
          },
          "additionalProperties": {
            "type": "number",
            "minimum": 1
          }
        },
        "modelConcurrency": {
          "type": "object",
          "propertyNames": {
            "type": "string"
          },
          "additionalProperties": {
            "type": "number",
            "minimum": 1
          }
        }
      }
    },
    "notification": {
      "type": "object",
      "properties": {
        "force_enable": {
          "type": "boolean"
        }
      }
    },
    "git_master": {
      "type": "object",
      "properties": {
        "commit_footer": {
          "default": true,
          "type": "boolean"
        },
        "include_co_authored_by": {
          "default": true,
          "type": "boolean"
        }
      }
    }
  }
}
</file>
<file path="internal/schema/validator.go">
package schema

import (
	_ "embed"
	"encoding/json"
	"fmt"

	"github.com/diogenes/omo-profiler/internal/config"
	"github.com/xeipuuv/gojsonschema"
)

//go:embed schema.json
var schemaJSON []byte

// ValidationError represents a single validation error
type ValidationError struct {
	Path    string // JSON path to the error
	Message string // Error message
}

func (e ValidationError) Error() string {
	return fmt.Sprintf("%s: %s", e.Path, e.Message)
}

// Validator validates configs against the embedded schema
type Validator struct {
	schema *gojsonschema.Schema
}

// NewValidator creates a new validator with the embedded schema
func NewValidator() (*Validator, error) {
	loader := gojsonschema.NewBytesLoader(schemaJSON)
	schema, err := gojsonschema.NewSchema(loader)
	if err != nil {
		return nil, err
	}
	return &Validator{schema: schema}, nil
}

// Validate validates a config against the schema
func (v *Validator) Validate(cfg *config.Config) ([]ValidationError, error) {
	// Marshal config to JSON for validation
	data, err := json.Marshal(cfg)
	if err != nil {
		return nil, err
	}

	loader := gojsonschema.NewBytesLoader(data)
	result, err := v.schema.Validate(loader)
	if err != nil {
		return nil, err
	}

	if result.Valid() {
		return nil, nil
	}

	var errors []ValidationError
	for _, e := range result.Errors() {
		errors = append(errors, ValidationError{
			Path:    e.Field(),
			Message: e.Description(),
		})
	}
	return errors, nil
}

// ValidateJSON validates raw JSON bytes against the schema
func (v *Validator) ValidateJSON(data []byte) ([]ValidationError, error) {
	loader := gojsonschema.NewBytesLoader(data)
	result, err := v.schema.Validate(loader)
	if err != nil {
		return nil, err
	}

	if result.Valid() {
		return nil, nil
	}

	var errors []ValidationError
	for _, e := range result.Errors() {
		errors = append(errors, ValidationError{
			Path:    e.Field(),
			Message: e.Description(),
		})
	}
	return errors, nil
}
</file>
<file path="internal/schema/validator_test.go">
package schema

import (
	"testing"

	"github.com/diogenes/omo-profiler/internal/config"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSchemaEmbedded(t *testing.T) {
	// Verify the schema is embedded and not empty
	assert.NotEmpty(t, schemaJSON, "embedded schemaJSON should not be empty")
	assert.Greater(t, len(schemaJSON), 100, "schemaJSON should contain substantial content")
}

func TestNewValidator(t *testing.T) {
	v, err := NewValidator()
	require.NoError(t, err, "NewValidator should succeed with valid embedded schema")
	assert.NotNil(t, v, "validator should not be nil")
	assert.NotNil(t, v.schema, "validator schema should not be nil")
}

func TestValidate_ValidConfig(t *testing.T) {
	v, err := NewValidator()
	require.NoError(t, err)

	// Empty config should be valid (all fields are optional)
	cfg := &config.Config{}
	errs, err := v.Validate(cfg)
	require.NoError(t, err)
	assert.Nil(t, errs, "empty config should be valid")
}

func TestValidate_ValidConfigWithAgents(t *testing.T) {
	v, err := NewValidator()
	require.NoError(t, err)

	temp := 0.7
	cfg := &config.Config{
		Agents: map[string]*config.AgentConfig{
			"build": {
				Model:       "claude-sonnet-4-20250514",
				Temperature: &temp,
				Color:       "#FF5733",
				Mode:        "primary",
			},
		},
	}

	errs, err := v.Validate(cfg)
	require.NoError(t, err)
	assert.Nil(t, errs, "valid config with agents should pass validation")
}

func TestValidate_InvalidTemperature(t *testing.T) {
	v, err := NewValidator()
	require.NoError(t, err)

	// Temperature > 2 should be invalid
	temp := 2.5
	cfg := &config.Config{
		Agents: map[string]*config.AgentConfig{
			"build": {
				Temperature: &temp,
			},
		},
	}

	errs, err := v.Validate(cfg)
	require.NoError(t, err)
	assert.NotNil(t, errs, "temperature > 2 should fail validation")
	assert.NotEmpty(t, errs, "should have validation errors")
}

func TestValidate_InvalidTopP(t *testing.T) {
	v, err := NewValidator()
	require.NoError(t, err)

	// top_p > 1 should be invalid
	topP := 1.5
	cfg := &config.Config{
		Agents: map[string]*config.AgentConfig{
			"plan": {
				TopP: &topP,
			},
		},
	}

	errs, err := v.Validate(cfg)
	require.NoError(t, err)
	assert.NotNil(t, errs, "top_p > 1 should fail validation")
}

func TestValidate_InvalidMode(t *testing.T) {
	v, err := NewValidator()
	require.NoError(t, err)

	// Invalid mode value
	cfg := &config.Config{
		Agents: map[string]*config.AgentConfig{
			"build": {
				Mode: "invalid_mode",
			},
		},
	}

	errs, err := v.Validate(cfg)
	require.NoError(t, err)
	assert.NotNil(t, errs, "invalid mode should fail validation")
}

func TestValidate_InvalidColor(t *testing.T) {
	v, err := NewValidator()
	require.NoError(t, err)

	// Color not matching #RRGGBB pattern
	cfg := &config.Config{
		Agents: map[string]*config.AgentConfig{
			"build": {
				Color: "red", // Should be #RRGGBB format
			},
		},
	}

	errs, err := v.Validate(cfg)
	require.NoError(t, err)
	assert.NotNil(t, errs, "invalid color format should fail validation")
}

func TestValidate_InvalidPermission(t *testing.T) {
	v, err := NewValidator()
	require.NoError(t, err)

	// Invalid permission value
	cfg := &config.Config{
		Agents: map[string]*config.AgentConfig{
			"build": {
				Permission: &config.PermissionConfig{
					Edit: "invalid_value", // Should be ask/allow/deny
				},
			},
		},
	}

	errs, err := v.Validate(cfg)
	require.NoError(t, err)
	assert.NotNil(t, errs, "invalid permission should fail validation")
}

func TestValidateJSON_ValidJSON(t *testing.T) {
	v, err := NewValidator()
	require.NoError(t, err)

	validJSON := []byte(`{}`)
	errs, err := v.ValidateJSON(validJSON)
	require.NoError(t, err)
	assert.Nil(t, errs, "empty JSON object should be valid")
}

func TestValidateJSON_ValidJSONWithAgents(t *testing.T) {
	v, err := NewValidator()
	require.NoError(t, err)

	validJSON := []byte(`{
		"agents": {
			"build": {
				"temperature": 0.7,
				"mode": "primary",
				"color": "#FF5733"
			}
		}
	}`)

	errs, err := v.ValidateJSON(validJSON)
	require.NoError(t, err)
	assert.Nil(t, errs, "valid JSON should pass validation")
}

func TestValidateJSON_InvalidTemperature(t *testing.T) {
	v, err := NewValidator()
	require.NoError(t, err)

	invalidJSON := []byte(`{
		"agents": {
			"build": {
				"temperature": 3.0
			}
		}
	}`)

	errs, err := v.ValidateJSON(invalidJSON)
	require.NoError(t, err)
	assert.NotNil(t, errs, "temperature > 2 in JSON should fail validation")
}

func TestValidateJSON_InvalidJSON(t *testing.T) {
	v, err := NewValidator()
	require.NoError(t, err)

	// Malformed JSON should return error
	invalidJSON := []byte(`{not valid json}`)
	_, err = v.ValidateJSON(invalidJSON)
	assert.Error(t, err, "malformed JSON should return error")
}

func TestValidationError_HasPath(t *testing.T) {
	v, err := NewValidator()
	require.NoError(t, err)

	temp := 3.0
	cfg := &config.Config{
		Agents: map[string]*config.AgentConfig{
			"build": {
				Temperature: &temp,
			},
		},
	}

	errs, err := v.Validate(cfg)
	require.NoError(t, err)
	require.NotEmpty(t, errs)

	// Check that validation errors have path and message
	for _, e := range errs {
		assert.NotEmpty(t, e.Message, "validation error should have a message")
	}
}

func TestValidationError_Error(t *testing.T) {
	e := ValidationError{
		Path:    "agents.build.temperature",
		Message: "Must be less than or equal to 2",
	}
	assert.Equal(t, "agents.build.temperature: Must be less than or equal to 2", e.Error())
}
</file>
<file path="internal/testdata/complex-permissions.json">
{
  "agents": {
    "Sisyphus": {
      "model": "anthropic/claude-4",
      "permission": {
        "edit": "allow",
        "bash": {
          "git": "allow",
          "npm": "ask",
          "rm": "deny"
        },
        "webfetch": "allow"
      }
    }
  }
}
</file>
<file path="internal/testdata/minimal-config.json">
{
  "agents": {
    "build": {
      "model": "claude-sonnet-4-20250514"
    }
  }
}
</file>
<file path="internal/testdata/skills-object.json">
{
  "agents": {
    "build": {
      "model": "anthropic/claude-4"
    }
  },
  "skills": {
    "sources": ["./custom-skills"],
    "enable": ["my-skill"],
    "disable": ["other-skill"],
    "my-skill": {
      "config": "value"
    }
  }
}
</file>
<file path="internal/testdata/valid-config.json">
{
  "$schema": "https://raw.githubusercontent.com/code-yeongyu/oh-my-opencode/master/assets/oh-my-opencode.schema.json",
  "disabled_mcps": ["context7"],
  "disabled_agents": ["oracle", "librarian"],
  "disabled_skills": ["playwright"],
  "disabled_hooks": ["auto-update-checker", "startup-toast"],
  "disabled_commands": ["init-deep"],
  "agents": {
    "build": {
      "model": "claude-sonnet-4-20250514",
      "variant": "fast",
      "category": "general",
      "skills": ["git-master"],
      "temperature": 0.7,
      "top_p": 0.9,
      "prompt": "You are a helpful coding assistant.",
      "prompt_append": "Always verify your work.",
      "tools": {
        "bash": true,
        "webfetch": false
      },
      "disable": false,
      "description": "Main build agent",
      "mode": "primary",
      "color": "#FF5733",
      "permission": {
        "edit": "allow",
        "bash": "allow",
        "webfetch": "ask",
        "doom_loop": "deny",
        "external_directory": "ask"
      }
    },
    "plan": {
      "model": "o3",
      "category": "planning",
      "permission": {
        "bash": {
          "git": "allow",
          "npm": "ask",
          "rm": "deny"
        }
      }
    }
  },
  "categories": {
    "general": {
      "model": "claude-sonnet-4-20250514",
      "variant": "balanced",
      "temperature": 0.5,
      "top_p": 0.95,
      "maxTokens": 8192,
      "thinking": {
        "type": "enabled",
        "budgetTokens": 4096
      },
      "reasoningEffort": "medium",
      "textVerbosity": "low",
      "tools": {
        "edit": true,
        "bash": true
      },
      "prompt_append": "Be concise."
    },
    "planning": {
      "model": "o3",
      "thinking": {
        "type": "enabled"
      }
    }
  },
  "claude_code": {
    "mcp": true,
    "commands": true,
    "skills": true,
    "agents": true,
    "hooks": true,
    "plugins": false,
    "plugins_override": {
      "context7": true
    }
  },
  "sisyphus_agent": {
    "disabled": false,
    "default_builder_enabled": true,
    "planner_enabled": true,
    "replace_plan": false
  },
  "comment_checker": {
    "custom_prompt": "Check for TODO comments."
  },
  "experimental": {
    "aggressive_truncation": true,
    "auto_resume": false,
    "preemptive_compaction": true,
    "preemptive_compaction_threshold": 0.8,
    "truncate_all_tool_outputs": false,
    "dynamic_context_pruning": {
      "enabled": true,
      "notification": "detailed",
      "turn_protection": {
        "enabled": true,
        "turns": 5
      },
      "protected_tools": ["task", "todowrite"],
      "strategies": {
        "deduplication": {
          "enabled": true
        },
        "supersede_writes": {
          "enabled": true,
          "aggressive": false
        },
        "purge_errors": {
          "enabled": true,
          "turns": 10
        }
      }
    },
    "dcp_for_compaction": false
  },
  "auto_update": true,
  "skills": ["git-master", "playwright"],
  "ralph_loop": {
    "enabled": true,
    "default_max_iterations": 50,
    "state_dir": "/tmp/ralph"
  },
  "background_task": {
    "defaultConcurrency": 4,
    "providerConcurrency": {
      "anthropic": 3,
      "openai": 5
    },
    "modelConcurrency": {
      "claude-sonnet-4": 2
    }
  },
  "notification": {
    "force_enable": true
  },
  "git_master": {
    "commit_footer": true,
    "include_co_authored_by": false
  }
}
</file>
<file path="internal/tui/views/dashboard.go">
package views

import (
	"fmt"

	"github.com/charmbracelet/bubbles/key"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/diogenes/omo-profiler/internal/profile"
)

type NavToListMsg struct{}
type NavToWizardMsg struct{}
type NavToEditorMsg struct{}
type NavToDiffMsg struct{}
type NavToImportMsg struct{}
type NavToExportMsg struct{}

const (
	menuSwitch = iota
	menuCreate
	menuEdit
	menuCompare
	menuImport
	menuExport
)

var menuItems = []string{
	"Switch Profile",
	"Create New",
	"Edit Current",
	"Compare Profiles",
	"Import Profile",
	"Export Profile",
}

type Dashboard struct {
	activeProfile *profile.ActiveConfig
	profileCount  int
	cursor        int
	width         int
	height        int
	keys          dashboardKeyMap
	err           error
}

type dashboardKeyMap struct {
	Up    key.Binding
	Down  key.Binding
	Enter key.Binding
}

var (
	titleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("#7D56F4"))

	subtitleStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#6C7086"))

	successStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#A6E3A1"))

	warningStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#F9E2AF"))

	grayStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#6C7086"))

	selectedStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("#CDD6F4")).
			Background(lipgloss.Color("#7D56F4"))

	normalStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#CDD6F4"))

	accentStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FF6AC1"))
)

func NewDashboard() Dashboard {
	return Dashboard{
		cursor: 0,
		keys: dashboardKeyMap{
			Up: key.NewBinding(
				key.WithKeys("up", "k"),
				key.WithHelp("↑/k", "up"),
			),
			Down: key.NewBinding(
				key.WithKeys("down", "j"),
				key.WithHelp("↓/j", "down"),
			),
			Enter: key.NewBinding(
				key.WithKeys("enter"),
				key.WithHelp("enter", "select"),
			),
		},
	}
}

func (d Dashboard) Init() tea.Cmd {
	return d.loadActiveProfile
}

func (d Dashboard) loadActiveProfile() tea.Msg {
	active, err := profile.GetActive()
	if err != nil {
		return profileLoadedMsg{err: err}
	}

	profiles, err := profile.List()
	if err != nil {
		return profileLoadedMsg{err: err}
	}

	return profileLoadedMsg{
		active: active,
		count:  len(profiles),
	}
}

type profileLoadedMsg struct {
	active *profile.ActiveConfig
	count  int
	err    error
}

func (d Dashboard) Update(msg tea.Msg) (Dashboard, tea.Cmd) {
	switch msg := msg.(type) {
	case profileLoadedMsg:
		if msg.err != nil {
			d.err = msg.err
		} else {
			d.activeProfile = msg.active
			d.profileCount = msg.count
		}

	case tea.WindowSizeMsg:
		d.width = msg.Width
		d.height = msg.Height

	case tea.KeyMsg:
		switch {
		case key.Matches(msg, d.keys.Up):
			if d.cursor > 0 {
				d.cursor--
			}
		case key.Matches(msg, d.keys.Down):
			if d.cursor < len(menuItems)-1 {
				d.cursor++
			}
		case key.Matches(msg, d.keys.Enter):
			return d, d.handleSelect()
		}
	}

	return d, nil
}

func (d Dashboard) handleSelect() tea.Cmd {
	return func() tea.Msg {
		switch d.cursor {
		case menuSwitch:
			return NavToListMsg{}
		case menuCreate:
			return NavToWizardMsg{}
		case menuEdit:
			return NavToEditorMsg{}
		case menuCompare:
			return NavToDiffMsg{}
		case menuImport:
			return NavToImportMsg{}
		case menuExport:
			return NavToExportMsg{}
		}
		return nil
	}
}

func (d Dashboard) View() string {
	title := titleStyle.Render("omo-profiler")
	subtitle := subtitleStyle.Render("Profile manager for oh-my-opencode")

	var profileStatus string
	if d.err != nil {
		profileStatus = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#F38BA8")).
			Render(fmt.Sprintf("Error: %v", d.err))
	} else if d.activeProfile == nil {
		profileStatus = grayStyle.Render("Loading...")
	} else if !d.activeProfile.Exists {
		profileStatus = fmt.Sprintf("Active: %s", grayStyle.Render("(None)"))
	} else if d.activeProfile.IsOrphan {
		profileStatus = fmt.Sprintf("Active: %s", warningStyle.Render("(Custom)"))
	} else {
		profileStatus = fmt.Sprintf("Active: %s", successStyle.Render(d.activeProfile.ProfileName))
	}

	statsLine := subtitleStyle.Render(fmt.Sprintf("%d profiles available", d.profileCount))
	menuView := d.renderMenu()

	return lipgloss.JoinVertical(lipgloss.Left,
		"",
		title,
		subtitle,
		"",
		profileStatus,
		statsLine,
		"",
		menuView,
	)
}

func (d Dashboard) renderMenu() string {
	var lines []string

	for i, item := range menuItems {
		cursor := "   "
		itemStyle := normalStyle

		if i == d.cursor {
			cursor = accentStyle.Render(" > ")
			itemStyle = selectedStyle
		}

		line := fmt.Sprintf("%s%s", cursor, itemStyle.Render(" "+item+" "))
		lines = append(lines, line)
	}

	return lipgloss.JoinVertical(lipgloss.Left, lines...)
}

func (d Dashboard) Refresh() tea.Cmd {
	return d.loadActiveProfile
}

func (d *Dashboard) SetSize(width, height int) {
	d.width = width
	d.height = height
}
</file>
<file path="internal/tui/views/diff.go">
package views

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/diogenes/omo-profiler/internal/diff"
	"github.com/diogenes/omo-profiler/internal/profile"
)

var (
	diffPurple  = lipgloss.Color("#7D56F4")
	diffMagenta = lipgloss.Color("#FF6AC1")
	diffGreen   = lipgloss.Color("#A6E3A1")
	diffRed     = lipgloss.Color("#F38BA8")
	diffGray    = lipgloss.Color("#6C7086")
	diffWhite   = lipgloss.Color("#CDD6F4")
)

var (
	diffTitleStyle    = lipgloss.NewStyle().Bold(true).Foreground(diffPurple)
	diffSubtitleStyle = lipgloss.NewStyle().Foreground(diffGray)
	diffErrorStyle    = lipgloss.NewStyle().Foreground(diffRed)
	diffHelpStyle     = lipgloss.NewStyle().Foreground(diffGray)
	diffActiveStyle   = lipgloss.NewStyle().Bold(true).Foreground(diffWhite).Background(diffPurple)
	diffInactiveStyle = lipgloss.NewStyle().Foreground(diffWhite)
	diffAccentStyle   = lipgloss.NewStyle().Foreground(diffMagenta)
	addedStyle        = lipgloss.NewStyle().Foreground(diffGreen)
	removedStyle      = lipgloss.NewStyle().Foreground(diffRed)
	equalStyle        = lipgloss.NewStyle().Foreground(diffWhite)
)

type focusedPane int

const (
	focusLeft focusedPane = iota
	focusRight
)

type Diff struct {
	width         int
	height        int
	ready         bool
	leftViewport  viewport.Model
	rightViewport viewport.Model

	profiles     []string
	leftProfile  string
	rightProfile string
	leftIdx      int
	rightIdx     int

	focused        focusedPane
	selectingLeft  bool
	selectingRight bool

	diffResult *diff.DiffResult
	err        error
}

func NewDiff() Diff {
	return Diff{
		focused: focusLeft,
	}
}

func (d Diff) Init() tea.Cmd {
	return d.loadProfiles
}

type diffProfilesLoadedMsg struct {
	profiles []string
	err      error
}

type diffComputedMsg struct {
	result *diff.DiffResult
	err    error
}

func (d Diff) loadProfiles() tea.Msg {
	profiles, err := profile.List()
	return diffProfilesLoadedMsg{profiles: profiles, err: err}
}

func (d Diff) computeDiff() tea.Msg {
	if d.leftProfile == "" || d.rightProfile == "" {
		return diffComputedMsg{result: nil, err: nil}
	}

	left, err := profile.Load(d.leftProfile)
	if err != nil {
		return diffComputedMsg{err: fmt.Errorf("loading left profile: %w", err)}
	}

	right, err := profile.Load(d.rightProfile)
	if err != nil {
		return diffComputedMsg{err: fmt.Errorf("loading right profile: %w", err)}
	}

	json1, err := json.MarshalIndent(left.Config, "", "  ")
	if err != nil {
		return diffComputedMsg{err: fmt.Errorf("marshaling left profile: %w", err)}
	}

	json2, err := json.MarshalIndent(right.Config, "", "  ")
	if err != nil {
		return diffComputedMsg{err: fmt.Errorf("marshaling right profile: %w", err)}
	}

	result, err := diff.ComputeDiff(json1, json2)
	return diffComputedMsg{result: result, err: err}
}

func (d Diff) Update(msg tea.Msg) (Diff, tea.Cmd) {
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		d.width = msg.Width
		d.height = msg.Height
		d.initViewports()
		d.updateViewportContent()

	case diffProfilesLoadedMsg:
		d.profiles = msg.profiles
		d.err = msg.err
		if len(d.profiles) >= 2 {
			d.leftProfile = d.profiles[0]
			d.rightProfile = d.profiles[1]
			d.leftIdx = 0
			d.rightIdx = 1
			return d, d.computeDiff
		}

	case diffComputedMsg:
		d.diffResult = msg.result
		d.err = msg.err
		d.updateViewportContent()

	case tea.KeyMsg:
		if d.selectingLeft || d.selectingRight {
			return d.handleSelectionKeys(msg)
		}
		return d.handleNavigationKeys(msg)
	}

	if d.ready {
		var cmd tea.Cmd
		d.leftViewport, cmd = d.leftViewport.Update(msg)
		cmds = append(cmds, cmd)
		d.rightViewport, cmd = d.rightViewport.Update(msg)
		cmds = append(cmds, cmd)
	}

	return d, tea.Batch(cmds...)
}

func (d Diff) handleNavigationKeys(msg tea.KeyMsg) (Diff, tea.Cmd) {
	switch msg.String() {
	case "up", "k":
		d.scrollBoth(-1)
	case "down", "j":
		d.scrollBoth(1)
	case "tab":
		if d.focused == focusLeft {
			d.focused = focusRight
		} else {
			d.focused = focusLeft
		}
	case "enter":
		if d.focused == focusLeft {
			d.selectingLeft = true
		} else {
			d.selectingRight = true
		}
	case "pgup":
		d.scrollBoth(-d.leftViewport.Height)
	case "pgdown":
		d.scrollBoth(d.leftViewport.Height)
	}
	return d, nil
}

func (d Diff) handleSelectionKeys(msg tea.KeyMsg) (Diff, tea.Cmd) {
	switch msg.String() {
	case "up", "k":
		if d.selectingLeft && d.leftIdx > 0 {
			d.leftIdx--
		} else if d.selectingRight && d.rightIdx > 0 {
			d.rightIdx--
		}
	case "down", "j":
		if d.selectingLeft && d.leftIdx < len(d.profiles)-1 {
			d.leftIdx++
		} else if d.selectingRight && d.rightIdx < len(d.profiles)-1 {
			d.rightIdx++
		}
	case "enter":
		if d.selectingLeft {
			d.leftProfile = d.profiles[d.leftIdx]
			d.selectingLeft = false
		} else {
			d.rightProfile = d.profiles[d.rightIdx]
			d.selectingRight = false
		}
		return d, d.computeDiff
	case "esc":
		d.selectingLeft = false
		d.selectingRight = false
	}
	return d, nil
}

func (d *Diff) scrollBoth(delta int) {
	if !d.ready {
		return
	}
	newOffset := d.leftViewport.YOffset + delta
	if newOffset < 0 {
		newOffset = 0
	}
	d.leftViewport.SetYOffset(newOffset)
	d.rightViewport.SetYOffset(newOffset)
}

func (d *Diff) initViewports() {
	if d.width == 0 || d.height == 0 {
		return
	}

	paneWidth := (d.width - 3) / 2
	paneHeight := d.height - 8

	if paneHeight < 1 {
		paneHeight = 1
	}

	if !d.ready {
		d.leftViewport = viewport.New(paneWidth, paneHeight)
		d.rightViewport = viewport.New(paneWidth, paneHeight)
		d.ready = true
	} else {
		d.leftViewport.Width = paneWidth
		d.leftViewport.Height = paneHeight
		d.rightViewport.Width = paneWidth
		d.rightViewport.Height = paneHeight
	}
}

func (d *Diff) updateViewportContent() {
	if !d.ready || d.diffResult == nil {
		return
	}

	leftContent := d.renderDiffPane(d.diffResult.Left, true)
	rightContent := d.renderDiffPane(d.diffResult.Right, false)

	d.leftViewport.SetContent(leftContent)
	d.rightViewport.SetContent(rightContent)
}

func (d Diff) renderDiffPane(lines []diff.DiffLine, isLeft bool) string {
	var sb strings.Builder

	for _, line := range lines {
		var lineStyle lipgloss.Style
		prefix := "  "

		switch line.Type {
		case diff.DiffEqual:
			lineStyle = equalStyle
		case diff.DiffAdded:
			lineStyle = addedStyle
			if !isLeft {
				prefix = "+ "
			}
		case diff.DiffRemoved:
			lineStyle = removedStyle
			if isLeft {
				prefix = "- "
			}
		}

		sb.WriteString(lineStyle.Render(prefix + line.Text))
		sb.WriteString("\n")
	}

	return sb.String()
}

func (d Diff) View() string {
	if d.err != nil {
		return diffErrorStyle.Render(fmt.Sprintf("Error: %v", d.err))
	}

	if len(d.profiles) == 0 {
		return diffSubtitleStyle.Render("No profiles available for comparison")
	}

	if len(d.profiles) < 2 {
		return diffSubtitleStyle.Render("Need at least 2 profiles for comparison")
	}

	title := diffTitleStyle.Render("Profile Diff")

	leftSelector := d.renderSelector(d.leftProfile, d.selectingLeft, d.leftIdx, d.focused == focusLeft)
	rightSelector := d.renderSelector(d.rightProfile, d.selectingRight, d.rightIdx, d.focused == focusRight)

	selectors := lipgloss.JoinHorizontal(lipgloss.Top, leftSelector, " ", rightSelector)

	var content string
	if d.ready && d.diffResult != nil {
		paneWidth := (d.width - 3) / 2

		leftBorder := lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(d.borderColor(focusLeft)).
			Width(paneWidth)

		rightBorder := lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(d.borderColor(focusRight)).
			Width(paneWidth)

		leftPane := leftBorder.Render(d.leftViewport.View())
		rightPane := rightBorder.Render(d.rightViewport.View())

		content = lipgloss.JoinHorizontal(lipgloss.Top, leftPane, " ", rightPane)
	} else if d.diffResult == nil && d.leftProfile != "" && d.rightProfile != "" {
		content = diffSubtitleStyle.Render("Computing diff...")
	} else {
		content = diffSubtitleStyle.Render("Select profiles to compare")
	}

	help := diffHelpStyle.Render("tab: switch pane • enter: select profile • ↑↓: scroll • esc: back")

	return lipgloss.JoinVertical(lipgloss.Left,
		title,
		"",
		selectors,
		"",
		content,
		"",
		help,
	)
}

func (d Diff) borderColor(pane focusedPane) lipgloss.Color {
	if d.focused == pane {
		return diffPurple
	}
	return diffGray
}

func (d Diff) renderSelector(selected string, isSelecting bool, idx int, isFocused bool) string {
	paneWidth := (d.width - 3) / 2
	if paneWidth < 20 {
		paneWidth = 20
	}

	var content string
	if isSelecting {
		var items []string
		for i, p := range d.profiles {
			cursor := "  "
			if i == idx {
				cursor = "> "
			}
			style := diffInactiveStyle
			if i == idx {
				style = diffActiveStyle
			}
			items = append(items, style.Render(cursor+p))
		}
		content = strings.Join(items, "\n")
	} else {
		content = diffAccentStyle.Render(selected)
	}

	borderColor := diffGray
	if isFocused {
		borderColor = diffPurple
	}

	return lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(borderColor).
		Width(paneWidth).
		Render(content)
}

func (d Diff) ShouldReturn() bool {
	return false
}
</file>
<file path="internal/tui/views/editor.go">
package views

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/textinput"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/diogenes/omo-profiler/internal/profile"
	"github.com/diogenes/omo-profiler/internal/schema"
)

// Message types
type EditorLoadMsg struct{ Profile *profile.Profile }
type EditorLoadErrorMsg struct{ Err error }
type EditorSaveMsg struct{}
type EditorSaveSuccessMsg struct{}
type EditorSaveErrorMsg struct{ Err error }
type EditorCancelMsg struct{}
type EditorSectionChangeMsg struct{ Section int }
type EditorValidationMsg struct{ Errors []schema.ValidationError }

// Editor sections
const (
	sectionName = iota
	sectionAgents
	sectionHooks
	sectionDisabled
	sectionOther
	sectionSkills
	sectionReview
)

var sectionNames = []string{
	"Name",
	"Agents",
	"Hooks",
	"Disabled",
	"Other",
	"Skills",
	"Review",
}

// Focus state
type editorFocus int

const (
	focusSidebar editorFocus = iota
	focusContent
)

// Styles
var (
	editorPurple  = lipgloss.Color("#7D56F4")
	editorMagenta = lipgloss.Color("#FF6AC1")
	editorGreen   = lipgloss.Color("#A6E3A1")
	editorRed     = lipgloss.Color("#F38BA8")
	editorYellow  = lipgloss.Color("#F9E2AF")
	editorGray    = lipgloss.Color("#6C7086")
	editorWhite   = lipgloss.Color("#CDD6F4")
)

var (
	editorTitleStyle    = lipgloss.NewStyle().Bold(true).Foreground(editorPurple)
	editorSubtitleStyle = lipgloss.NewStyle().Foreground(editorGray)
	editorErrorStyle    = lipgloss.NewStyle().Foreground(editorRed)
	editorSuccessStyle  = lipgloss.NewStyle().Foreground(editorGreen)
	editorHelpStyle     = lipgloss.NewStyle().Foreground(editorGray)
	editorActiveStyle   = lipgloss.NewStyle().Bold(true).Foreground(editorWhite).Background(editorPurple)
	editorInactiveStyle = lipgloss.NewStyle().Foreground(editorWhite)
	editorAccentStyle   = lipgloss.NewStyle().Foreground(editorMagenta)
	editorWarningStyle  = lipgloss.NewStyle().Foreground(editorYellow)
)

type editorKeyMap struct {
	Up     key.Binding
	Down   key.Binding
	Tab    key.Binding
	Enter  key.Binding
	Escape key.Binding
	Save   key.Binding
	Toggle key.Binding
}

func newEditorKeyMap() editorKeyMap {
	return editorKeyMap{
		Up: key.NewBinding(
			key.WithKeys("up", "k"),
			key.WithHelp("↑/k", "up"),
		),
		Down: key.NewBinding(
			key.WithKeys("down", "j"),
			key.WithHelp("↓/j", "down"),
		),
		Tab: key.NewBinding(
			key.WithKeys("tab"),
			key.WithHelp("tab", "switch focus"),
		),
		Enter: key.NewBinding(
			key.WithKeys("enter"),
			key.WithHelp("enter", "select/toggle"),
		),
		Escape: key.NewBinding(
			key.WithKeys("esc"),
			key.WithHelp("esc", "back"),
		),
		Save: key.NewBinding(
			key.WithKeys("ctrl+s"),
			key.WithHelp("ctrl+s", "save"),
		),
		Toggle: key.NewBinding(
			key.WithKeys(" "),
			key.WithHelp("space", "toggle"),
		),
	}
}

type Editor struct {
	// Profile data
	originalProfile *profile.Profile
	workingProfile  *profile.Profile
	profileName     string

	// UI state
	section int
	focus   editorFocus
	width   int
	height  int
	ready   bool
	keys    editorKeyMap

	// Components
	nameInput textinput.Model
	viewport  viewport.Model

	// Content navigation
	contentCursor int
	contentItems  []string

	// Status
	loading       bool
	saving        bool
	err           error
	successMsg    string
	validationErr []schema.ValidationError

	// Hooks toggle state (which hooks are enabled)
	hooksEnabled map[string]bool

	// Available options
	availableAgents []string
	availableHooks  []string
}

func NewEditor(profileName string) Editor {
	ti := textinput.New()
	ti.Placeholder = "profile-name"
	ti.CharLimit = 64

	return Editor{
		profileName:     profileName,
		section:         sectionName,
		focus:           focusSidebar,
		keys:            newEditorKeyMap(),
		nameInput:       ti,
		loading:         true,
		hooksEnabled:    make(map[string]bool),
		availableAgents: []string{"build", "oracle", "explore", "librarian"},
		availableHooks:  []string{"pre-tool", "post-tool", "pre-response", "notification"},
	}
}

func (e Editor) Init() tea.Cmd {
	return e.loadProfile
}

func (e Editor) loadProfile() tea.Msg {
	p, err := profile.Load(e.profileName)
	if err != nil {
		return EditorLoadErrorMsg{Err: err}
	}
	return EditorLoadMsg{Profile: p}
}

func (e *Editor) SetSize(width, height int) {
	e.width = width
	e.height = height

	contentWidth := width - 20 // sidebar width
	contentHeight := height - 10

	if contentHeight < 1 {
		contentHeight = 1
	}

	if !e.ready {
		e.viewport = viewport.New(contentWidth, contentHeight)
		e.ready = true
	} else {
		e.viewport.Width = contentWidth
		e.viewport.Height = contentHeight
	}

	e.nameInput.Width = contentWidth - 4
}

func (e Editor) Update(msg tea.Msg) (Editor, tea.Cmd) {
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		e.SetSize(msg.Width, msg.Height)
		return e, nil

	case EditorLoadMsg:
		e.loading = false
		e.originalProfile = msg.Profile
		// Deep copy for working profile
		e.workingProfile = &profile.Profile{
			Name:   msg.Profile.Name,
			Config: msg.Profile.Config,
			Path:   msg.Profile.Path,
		}
		e.nameInput.SetValue(msg.Profile.Name)
		e.initHooksState()
		e.updateContentItems()
		return e, nil

	case EditorLoadErrorMsg:
		e.loading = false
		e.err = msg.Err
		return e, nil

	case EditorSaveSuccessMsg:
		e.saving = false
		e.successMsg = "Profile saved successfully!"
		e.err = nil
		e.validationErr = nil
		return e, nil

	case EditorSaveErrorMsg:
		e.saving = false
		e.err = msg.Err
		return e, nil

	case EditorValidationMsg:
		e.saving = false
		e.validationErr = msg.Errors
		return e, nil

	case tea.KeyMsg:
		// Clear success message on any key
		e.successMsg = ""

		// Handle save shortcut globally
		if key.Matches(msg, e.keys.Save) {
			return e, e.saveProfile
		}

		if e.focus == focusSidebar {
			return e.handleSidebarKeys(msg)
		}
		return e.handleContentKeys(msg)
	}

	// Update sub-components
	if e.focus == focusContent && e.section == sectionName {
		var cmd tea.Cmd
		e.nameInput, cmd = e.nameInput.Update(msg)
		cmds = append(cmds, cmd)
	}

	if e.ready {
		var cmd tea.Cmd
		e.viewport, cmd = e.viewport.Update(msg)
		cmds = append(cmds, cmd)
	}

	return e, tea.Batch(cmds...)
}

func (e Editor) handleSidebarKeys(msg tea.KeyMsg) (Editor, tea.Cmd) {
	switch {
	case key.Matches(msg, e.keys.Up):
		if e.section > 0 {
			e.section--
			e.contentCursor = 0
			e.updateContentItems()
		}
	case key.Matches(msg, e.keys.Down):
		if e.section < len(sectionNames)-1 {
			e.section++
			e.contentCursor = 0
			e.updateContentItems()
		}
	case key.Matches(msg, e.keys.Tab), key.Matches(msg, e.keys.Enter):
		e.focus = focusContent
		e.contentCursor = 0
		if e.section == sectionName {
			e.nameInput.Focus()
			return e, textinput.Blink
		}
	case key.Matches(msg, e.keys.Escape):
		return e, func() tea.Msg { return EditorCancelMsg{} }
	}
	return e, nil
}

func (e Editor) handleContentKeys(msg tea.KeyMsg) (Editor, tea.Cmd) {
	switch {
	case key.Matches(msg, e.keys.Escape):
		e.focus = focusSidebar
		e.nameInput.Blur()
		return e, nil

	case key.Matches(msg, e.keys.Tab):
		e.focus = focusSidebar
		e.nameInput.Blur()
		return e, nil

	case key.Matches(msg, e.keys.Up):
		if e.contentCursor > 0 {
			e.contentCursor--
		}

	case key.Matches(msg, e.keys.Down):
		if e.contentCursor < len(e.contentItems)-1 {
			e.contentCursor++
		}

	case key.Matches(msg, e.keys.Enter), key.Matches(msg, e.keys.Toggle):
		return e.handleContentAction()
	}

	// Handle text input for name section
	if e.section == sectionName {
		var cmd tea.Cmd
		e.nameInput, cmd = e.nameInput.Update(msg)
		// Update working profile name
		e.workingProfile.Name = e.nameInput.Value()
		return e, cmd
	}

	return e, nil
}

func (e Editor) handleContentAction() (Editor, tea.Cmd) {
	if e.workingProfile == nil {
		return e, nil
	}

	switch e.section {
	case sectionHooks:
		if e.contentCursor < len(e.availableHooks) {
			hook := e.availableHooks[e.contentCursor]
			e.hooksEnabled[hook] = !e.hooksEnabled[hook]
			e.updateDisabledHooks()
		}

	case sectionDisabled:
		e.toggleDisabledItem()

	case sectionReview:
		// Save on enter in review section
		return e, e.saveProfile
	}

	return e, nil
}

func (e *Editor) initHooksState() {
	if e.workingProfile == nil {
		return
	}

	// All hooks enabled by default
	for _, h := range e.availableHooks {
		e.hooksEnabled[h] = true
	}

	// Mark disabled hooks
	for _, h := range e.workingProfile.Config.DisabledHooks {
		e.hooksEnabled[h] = false
	}
}

func (e *Editor) updateDisabledHooks() {
	if e.workingProfile == nil {
		return
	}

	var disabled []string
	for _, h := range e.availableHooks {
		if !e.hooksEnabled[h] {
			disabled = append(disabled, h)
		}
	}
	e.workingProfile.Config.DisabledHooks = disabled
}

func (e *Editor) toggleDisabledItem() {
	if e.workingProfile == nil || e.contentCursor >= len(e.contentItems) {
		return
	}

	item := e.contentItems[e.contentCursor]
	// Parse the item to determine type and value
	parts := strings.SplitN(item, ": ", 2)
	if len(parts) != 2 {
		return
	}

	category := parts[0]
	values := strings.Split(parts[1], ", ")
	if len(values) == 0 || values[0] == "(none)" {
		return
	}

	// Toggle first item in the list (simplified)
	switch category {
	case "MCPs":
		if len(e.workingProfile.Config.DisabledMCPs) > 0 {
			e.workingProfile.Config.DisabledMCPs = e.workingProfile.Config.DisabledMCPs[1:]
		}
	case "Agents":
		if len(e.workingProfile.Config.DisabledAgents) > 0 {
			e.workingProfile.Config.DisabledAgents = e.workingProfile.Config.DisabledAgents[1:]
		}
	case "Skills":
		if len(e.workingProfile.Config.DisabledSkills) > 0 {
			e.workingProfile.Config.DisabledSkills = e.workingProfile.Config.DisabledSkills[1:]
		}
	case "Commands":
		if len(e.workingProfile.Config.DisabledCommands) > 0 {
			e.workingProfile.Config.DisabledCommands = e.workingProfile.Config.DisabledCommands[1:]
		}
	}
	e.updateContentItems()
}

func (e *Editor) updateContentItems() {
	if e.workingProfile == nil {
		e.contentItems = []string{}
		return
	}

	switch e.section {
	case sectionName:
		e.contentItems = []string{"Profile Name"}

	case sectionAgents:
		e.contentItems = []string{}
		for name := range e.workingProfile.Config.Agents {
			e.contentItems = append(e.contentItems, name)
		}
		if len(e.contentItems) == 0 {
			e.contentItems = []string{"(no agents configured)"}
		}

	case sectionHooks:
		e.contentItems = e.availableHooks

	case sectionDisabled:
		e.contentItems = []string{
			fmt.Sprintf("MCPs: %s", formatList(e.workingProfile.Config.DisabledMCPs)),
			fmt.Sprintf("Agents: %s", formatList(e.workingProfile.Config.DisabledAgents)),
			fmt.Sprintf("Skills: %s", formatList(e.workingProfile.Config.DisabledSkills)),
			fmt.Sprintf("Commands: %s", formatList(e.workingProfile.Config.DisabledCommands)),
		}

	case sectionOther:
		e.contentItems = []string{
			fmt.Sprintf("Auto Update: %s", formatBoolPtr(e.workingProfile.Config.AutoUpdate)),
		}
		if e.workingProfile.Config.ClaudeCode != nil {
			e.contentItems = append(e.contentItems,
				fmt.Sprintf("MCP: %s", formatBoolPtr(e.workingProfile.Config.ClaudeCode.MCP)),
				fmt.Sprintf("Commands: %s", formatBoolPtr(e.workingProfile.Config.ClaudeCode.Commands)),
				fmt.Sprintf("Skills: %s", formatBoolPtr(e.workingProfile.Config.ClaudeCode.Skills)),
				fmt.Sprintf("Agents: %s", formatBoolPtr(e.workingProfile.Config.ClaudeCode.Agents)),
				fmt.Sprintf("Hooks: %s", formatBoolPtr(e.workingProfile.Config.ClaudeCode.Hooks)),
			)
		}

	case sectionSkills:
		if e.workingProfile.Config.Skills != nil {
			e.contentItems = []string{"(JSON data - view only)"}
		} else {
			e.contentItems = []string{"(no skills configured)"}
		}

	case sectionReview:
		e.contentItems = []string{"Save Profile"}
	}
}

func formatList(items []string) string {
	if len(items) == 0 {
		return "(none)"
	}
	return strings.Join(items, ", ")
}

func formatBoolPtr(b *bool) string {
	if b == nil {
		return "(default)"
	}
	if *b {
		return "enabled"
	}
	return "disabled"
}

func (e Editor) saveProfile() tea.Msg {
	if e.workingProfile == nil {
		return EditorSaveErrorMsg{Err: fmt.Errorf("no profile loaded")}
	}

	// Validate name
	if err := profile.ValidateName(e.workingProfile.Name); err != nil {
		return EditorSaveErrorMsg{Err: fmt.Errorf("invalid name: %w", err)}
	}

	// Validate against schema
	validator, err := schema.NewValidator()
	if err != nil {
		return EditorSaveErrorMsg{Err: fmt.Errorf("validator error: %w", err)}
	}

	validationErrors, err := validator.Validate(&e.workingProfile.Config)
	if err != nil {
		return EditorSaveErrorMsg{Err: fmt.Errorf("validation error: %w", err)}
	}

	if len(validationErrors) > 0 {
		return EditorValidationMsg{Errors: validationErrors}
	}

	// Handle rename
	if e.workingProfile.Name != e.originalProfile.Name {
		// Delete old profile
		if err := profile.Delete(e.originalProfile.Name); err != nil {
			return EditorSaveErrorMsg{Err: fmt.Errorf("failed to delete old profile: %w", err)}
		}
	}

	// Save profile
	if err := e.workingProfile.Save(); err != nil {
		return EditorSaveErrorMsg{Err: err}
	}

	return EditorSaveSuccessMsg{}
}

func (e Editor) View() string {
	if e.loading {
		return editorSubtitleStyle.Render("Loading profile...")
	}

	if e.err != nil && e.workingProfile == nil {
		return editorErrorStyle.Render(fmt.Sprintf("Error: %v", e.err))
	}

	title := editorTitleStyle.Render(fmt.Sprintf("Edit Profile: %s", e.profileName))

	// Build sidebar
	sidebar := e.renderSidebar()

	// Build content
	content := e.renderContent()

	// Layout
	sidebarWidth := 16
	sidebarBorder := lipgloss.RoundedBorder()
	sidebarStyle := lipgloss.NewStyle().
		Border(sidebarBorder).
		BorderForeground(e.borderColor(focusSidebar)).
		Width(sidebarWidth).
		Padding(0, 1)

	contentBorder := lipgloss.RoundedBorder()
	contentWidth := e.width - sidebarWidth - 6
	if contentWidth < 20 {
		contentWidth = 20
	}
	contentStyle := lipgloss.NewStyle().
		Border(contentBorder).
		BorderForeground(e.borderColor(focusContent)).
		Width(contentWidth).
		Padding(0, 1)

	sidebarView := sidebarStyle.Render(sidebar)
	contentView := contentStyle.Render(content)

	mainView := lipgloss.JoinHorizontal(lipgloss.Top, sidebarView, " ", contentView)

	// Status bar
	var status string
	if e.successMsg != "" {
		status = editorSuccessStyle.Render(e.successMsg)
	} else if e.err != nil {
		status = editorErrorStyle.Render(fmt.Sprintf("Error: %v", e.err))
	} else if len(e.validationErr) > 0 {
		var errMsgs []string
		for _, ve := range e.validationErr {
			errMsgs = append(errMsgs, ve.Error())
		}
		status = editorErrorStyle.Render("Validation errors: " + strings.Join(errMsgs, "; "))
	} else if e.saving {
		status = editorSubtitleStyle.Render("Saving...")
	}

	help := editorHelpStyle.Render("↑↓ navigate • tab switch focus • ctrl+s save • esc back")

	return lipgloss.JoinVertical(lipgloss.Left,
		title,
		"",
		mainView,
		"",
		status,
		help,
	)
}

func (e Editor) borderColor(focus editorFocus) lipgloss.Color {
	if e.focus == focus {
		return editorPurple
	}
	return editorGray
}

func (e Editor) renderSidebar() string {
	var lines []string

	for i, name := range sectionNames {
		cursor := "  "
		style := editorInactiveStyle

		if i == e.section {
			cursor = "> "
			if e.focus == focusSidebar {
				style = editorActiveStyle
			} else {
				style = editorAccentStyle
			}
		}

		lines = append(lines, style.Render(cursor+name))
	}

	return strings.Join(lines, "\n")
}

func (e Editor) renderContent() string {
	if e.workingProfile == nil {
		return editorSubtitleStyle.Render("No profile loaded")
	}

	switch e.section {
	case sectionName:
		return e.renderNameSection()
	case sectionAgents:
		return e.renderAgentsSection()
	case sectionHooks:
		return e.renderHooksSection()
	case sectionDisabled:
		return e.renderDisabledSection()
	case sectionOther:
		return e.renderOtherSection()
	case sectionSkills:
		return e.renderSkillsSection()
	case sectionReview:
		return e.renderReviewSection()
	}

	return ""
}

func (e Editor) renderNameSection() string {
	label := editorSubtitleStyle.Render("Profile Name:")
	input := e.nameInput.View()

	return lipgloss.JoinVertical(lipgloss.Left, label, input)
}

func (e Editor) renderAgentsSection() string {
	if len(e.workingProfile.Config.Agents) == 0 {
		return editorSubtitleStyle.Render("No agents configured in this profile.")
	}

	var lines []string
	lines = append(lines, editorSubtitleStyle.Render("Configured Agents:"))
	lines = append(lines, "")

	i := 0
	for name, agent := range e.workingProfile.Config.Agents {
		cursor := "  "
		style := editorInactiveStyle
		if e.focus == focusContent && i == e.contentCursor {
			cursor = "> "
			style = editorActiveStyle
		}

		info := name
		if agent != nil && agent.Model != "" {
			info += fmt.Sprintf(" (%s)", agent.Model)
		}
		lines = append(lines, style.Render(cursor+info))
		i++
	}

	return strings.Join(lines, "\n")
}

func (e Editor) renderHooksSection() string {
	var lines []string
	lines = append(lines, editorSubtitleStyle.Render("Hooks (space to toggle):"))
	lines = append(lines, "")

	for i, hook := range e.availableHooks {
		cursor := "  "
		style := editorInactiveStyle
		if e.focus == focusContent && i == e.contentCursor {
			cursor = "> "
			style = editorActiveStyle
		}

		checkbox := "[ ]"
		if e.hooksEnabled[hook] {
			checkbox = "[x]"
		}

		lines = append(lines, style.Render(fmt.Sprintf("%s%s %s", cursor, checkbox, hook)))
	}

	return strings.Join(lines, "\n")
}

func (e Editor) renderDisabledSection() string {
	var lines []string
	lines = append(lines, editorSubtitleStyle.Render("Disabled Items:"))
	lines = append(lines, "")

	items := []struct {
		label string
		list  []string
	}{
		{"MCPs", e.workingProfile.Config.DisabledMCPs},
		{"Agents", e.workingProfile.Config.DisabledAgents},
		{"Skills", e.workingProfile.Config.DisabledSkills},
		{"Commands", e.workingProfile.Config.DisabledCommands},
	}

	for i, item := range items {
		cursor := "  "
		style := editorInactiveStyle
		if e.focus == focusContent && i == e.contentCursor {
			cursor = "> "
			style = editorActiveStyle
		}

		value := "(none)"
		if len(item.list) > 0 {
			value = strings.Join(item.list, ", ")
		}

		lines = append(lines, style.Render(fmt.Sprintf("%s%s: %s", cursor, item.label, value)))
	}

	return strings.Join(lines, "\n")
}

func (e Editor) renderOtherSection() string {
	var lines []string
	lines = append(lines, editorSubtitleStyle.Render("Other Settings:"))
	lines = append(lines, "")

	lines = append(lines, fmt.Sprintf("Auto Update: %s", formatBoolPtr(e.workingProfile.Config.AutoUpdate)))

	if e.workingProfile.Config.ClaudeCode != nil {
		cc := e.workingProfile.Config.ClaudeCode
		lines = append(lines, "")
		lines = append(lines, editorSubtitleStyle.Render("Claude Code:"))
		lines = append(lines, fmt.Sprintf("  MCP: %s", formatBoolPtr(cc.MCP)))
		lines = append(lines, fmt.Sprintf("  Commands: %s", formatBoolPtr(cc.Commands)))
		lines = append(lines, fmt.Sprintf("  Skills: %s", formatBoolPtr(cc.Skills)))
		lines = append(lines, fmt.Sprintf("  Agents: %s", formatBoolPtr(cc.Agents)))
		lines = append(lines, fmt.Sprintf("  Hooks: %s", formatBoolPtr(cc.Hooks)))
	}

	if e.workingProfile.Config.SisyphusAgent != nil {
		sa := e.workingProfile.Config.SisyphusAgent
		lines = append(lines, "")
		lines = append(lines, editorSubtitleStyle.Render("Sisyphus Agent:"))
		lines = append(lines, fmt.Sprintf("  Disabled: %s", formatBoolPtr(sa.Disabled)))
		lines = append(lines, fmt.Sprintf("  Default Builder: %s", formatBoolPtr(sa.DefaultBuilderEnabled)))
		lines = append(lines, fmt.Sprintf("  Planner: %s", formatBoolPtr(sa.PlannerEnabled)))
	}

	if e.workingProfile.Config.Experimental != nil {
		exp := e.workingProfile.Config.Experimental
		lines = append(lines, "")
		lines = append(lines, editorSubtitleStyle.Render("Experimental:"))
		lines = append(lines, fmt.Sprintf("  Aggressive Truncation: %s", formatBoolPtr(exp.AggressiveTruncation)))
		lines = append(lines, fmt.Sprintf("  Auto Resume: %s", formatBoolPtr(exp.AutoResume)))
		lines = append(lines, fmt.Sprintf("  Preemptive Compaction: %s", formatBoolPtr(exp.PreemptiveCompaction)))
	}

	return strings.Join(lines, "\n")
}

func (e Editor) renderSkillsSection() string {
	var lines []string
	lines = append(lines, editorSubtitleStyle.Render("Skills Configuration:"))
	lines = append(lines, "")

	if e.workingProfile.Config.Skills == nil {
		lines = append(lines, editorSubtitleStyle.Render("(no skills configured)"))
	} else {
		// Pretty print skills JSON
		var prettyJSON []byte
		prettyJSON, err := json.MarshalIndent(e.workingProfile.Config.Skills, "", "  ")
		if err != nil {
			lines = append(lines, editorErrorStyle.Render("Error formatting skills"))
		} else {
			lines = append(lines, string(prettyJSON))
		}
	}

	return strings.Join(lines, "\n")
}

func (e Editor) renderReviewSection() string {
	var lines []string
	lines = append(lines, editorSubtitleStyle.Render("Review & Save:"))
	lines = append(lines, "")

	// Show JSON preview
	jsonData, err := json.MarshalIndent(e.workingProfile.Config, "", "  ")
	if err != nil {
		lines = append(lines, editorErrorStyle.Render("Error generating preview"))
	} else {
		// Truncate if too long
		preview := string(jsonData)
		previewLines := strings.Split(preview, "\n")
		maxLines := 15
		if len(previewLines) > maxLines {
			previewLines = previewLines[:maxLines]
			previewLines = append(previewLines, "...")
		}
		lines = append(lines, strings.Join(previewLines, "\n"))
	}

	lines = append(lines, "")

	// Save button
	cursor := "  "
	style := editorInactiveStyle
	if e.focus == focusContent && e.contentCursor == 0 {
		cursor = "> "
		style = editorActiveStyle
	}
	lines = append(lines, style.Render(cursor+"[ Save Profile ]"))

	return strings.Join(lines, "\n")
}

// ShouldReturn indicates if the editor should return to previous view
func (e Editor) ShouldReturn() bool {
	return false
}

// ProfileName returns the name of the profile being edited
func (e Editor) ProfileName() string {
	return e.profileName
}

// HasChanges returns true if the profile has been modified
func (e Editor) HasChanges() bool {
	if e.originalProfile == nil || e.workingProfile == nil {
		return false
	}

	origJSON, err1 := json.Marshal(e.originalProfile.Config)
	workJSON, err2 := json.Marshal(e.workingProfile.Config)

	if err1 != nil || err2 != nil {
		return true
	}

	return string(origJSON) != string(workJSON) || e.originalProfile.Name != e.workingProfile.Name
}
</file>
<file path="internal/tui/views/list.go">
package views

import (
	"fmt"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/list"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/diogenes/omo-profiler/internal/profile"
)

type SwitchProfileMsg struct{ Name string }
type EditProfileMsg struct{ Name string }
type DeleteProfileMsg struct{ Name string }
type ConfirmDeleteMsg struct{ Confirmed bool }
type NavigateToWizardMsg struct{}
type NavigateToDashboardMsg struct{}

type profileItem struct {
	name     string
	isActive bool
}

func (i profileItem) Title() string {
	if i.isActive {
		return "* " + i.name + " (active)"
	}
	return "  " + i.name
}

func (i profileItem) Description() string {
	if i.isActive {
		return "Currently active profile"
	}
	return "Press enter to switch"
}

func (i profileItem) FilterValue() string {
	return i.name
}

type listKeyMap struct {
	Switch key.Binding
	Edit   key.Binding
	Delete key.Binding
	New    key.Binding
	Search key.Binding
	Back   key.Binding
}

func newListKeyMap() listKeyMap {
	return listKeyMap{
		Switch: key.NewBinding(
			key.WithKeys("enter"),
			key.WithHelp("enter", "switch profile"),
		),
		Edit: key.NewBinding(
			key.WithKeys("e"),
			key.WithHelp("e", "edit"),
		),
		Delete: key.NewBinding(
			key.WithKeys("d"),
			key.WithHelp("d", "delete"),
		),
		New: key.NewBinding(
			key.WithKeys("n"),
			key.WithHelp("n", "new profile"),
		),
		Search: key.NewBinding(
			key.WithKeys("/"),
			key.WithHelp("/", "search"),
		),
		Back: key.NewBinding(
			key.WithKeys("esc"),
			key.WithHelp("esc", "back"),
		),
	}
}

type List struct {
	list             list.Model
	keys             listKeyMap
	width            int
	height           int
	confirmingDelete bool
	deleteTarget     string
	err              error
}

func NewList() List {
	keys := newListKeyMap()

	delegate := list.NewDefaultDelegate()
	delegate.Styles.SelectedTitle = delegate.Styles.SelectedTitle.
		Foreground(lipgloss.Color("#7D56F4")).
		BorderForeground(lipgloss.Color("#7D56F4"))
	delegate.Styles.SelectedDesc = delegate.Styles.SelectedDesc.
		Foreground(lipgloss.Color("#6C7086"))

	l := list.New([]list.Item{}, delegate, 0, 0)
	l.Title = "Profiles"
	l.SetShowStatusBar(true)
	l.SetFilteringEnabled(true)
	l.SetShowHelp(false)
	l.Styles.Title = lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("#7D56F4")).
		Padding(0, 1)

	return List{
		list: l,
		keys: keys,
	}
}

func (l List) Init() tea.Cmd {
	return l.loadProfiles
}

func (l List) loadProfiles() tea.Msg {
	return listProfilesLoadedMsg{}
}

type listProfilesLoadedMsg struct{}

func (l *List) LoadProfiles() error {
	names, err := profile.List()
	if err != nil {
		l.err = err
		return err
	}

	active, err := profile.GetActive()
	if err != nil {
		l.err = err
		return err
	}

	items := make([]list.Item, len(names))
	for i, name := range names {
		isActive := active != nil && !active.IsOrphan && active.ProfileName == name
		items[i] = profileItem{
			name:     name,
			isActive: isActive,
		}
	}

	l.list.SetItems(items)
	l.err = nil
	return nil
}

func (l *List) SetSize(width, height int) {
	l.width = width
	l.height = height
	l.list.SetSize(width, height-4)
}

func (l List) Update(msg tea.Msg) (List, tea.Cmd) {
	var cmd tea.Cmd
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case listProfilesLoadedMsg:
		l.LoadProfiles()
		return l, nil

	case tea.WindowSizeMsg:
		l.SetSize(msg.Width, msg.Height)
		return l, nil

	case tea.KeyMsg:
		if l.confirmingDelete {
			switch msg.String() {
			case "y", "Y":
				l.confirmingDelete = false
				target := l.deleteTarget
				l.deleteTarget = ""
				return l, func() tea.Msg {
					return DeleteProfileMsg{Name: target}
				}
			case "n", "N", "esc":
				l.confirmingDelete = false
				l.deleteTarget = ""
				return l, nil
			}
			return l, nil
		}

		if l.list.FilterState() == list.Filtering {
			break
		}

		switch {
		case key.Matches(msg, l.keys.Back):
			return l, func() tea.Msg {
				return NavigateToDashboardMsg{}
			}

		case key.Matches(msg, l.keys.Switch):
			if item, ok := l.list.SelectedItem().(profileItem); ok {
				if !item.isActive {
					return l, func() tea.Msg {
						return SwitchProfileMsg{Name: item.name}
					}
				}
			}

		case key.Matches(msg, l.keys.Edit):
			if item, ok := l.list.SelectedItem().(profileItem); ok {
				return l, func() tea.Msg {
					return EditProfileMsg{Name: item.name}
				}
			}

		case key.Matches(msg, l.keys.Delete):
			if item, ok := l.list.SelectedItem().(profileItem); ok {
				l.confirmingDelete = true
				l.deleteTarget = item.name
				return l, nil
			}

		case key.Matches(msg, l.keys.New):
			return l, func() tea.Msg {
				return NavigateToWizardMsg{}
			}

		case key.Matches(msg, l.keys.Search):
			l.list.SetFilteringEnabled(true)
		}

	case ConfirmDeleteMsg:
		if msg.Confirmed && l.deleteTarget != "" {
			return l, func() tea.Msg {
				return DeleteProfileMsg{Name: l.deleteTarget}
			}
		}
		l.confirmingDelete = false
		l.deleteTarget = ""
		return l, nil
	}

	l.list, cmd = l.list.Update(msg)
	cmds = append(cmds, cmd)

	return l, tea.Batch(cmds...)
}

func (l List) View() string {
	var content string

	if l.err != nil {
		errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#F38BA8"))
		content = errorStyle.Render(fmt.Sprintf("Error: %v", l.err))
	} else {
		content = l.list.View()
	}

	if l.confirmingDelete {
		confirmStyle := lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("#F9E2AF")).
			Background(lipgloss.Color("#45475A")).
			Padding(0, 1)
		confirmText := confirmStyle.Render(fmt.Sprintf("Delete '%s'? [y/n]", l.deleteTarget))
		return lipgloss.JoinVertical(lipgloss.Left, content, "", confirmText)
	}

	return content
}

func (l List) SelectedProfile() string {
	if item, ok := l.list.SelectedItem().(profileItem); ok {
		return item.name
	}
	return ""
}

func (l List) IsConfirmingDelete() bool {
	return l.confirmingDelete
}
</file>
<file path="internal/tui/views/wizard.go">
package views

import (
	"github.com/charmbracelet/bubbles/key"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/diogenes/omo-profiler/internal/config"
	"github.com/diogenes/omo-profiler/internal/profile"
)

// Wizard message types
type WizardNextMsg struct{}
type WizardBackMsg struct{}
type WizardSaveMsg struct{ Profile *profile.Profile }
type WizardCancelMsg struct{}

const (
	StepName = iota + 1
	StepAgents
	StepHooks
	StepOther
	StepReview
)

var stepNames = map[int]string{
	StepName:   "Name",
	StepAgents: "Agents",
	StepHooks:  "Hooks",
	StepOther:  "Other Settings",
	StepReview: "Review & Save",
}

type wizardKeyMap struct {
	Next   key.Binding
	Back   key.Binding
	Cancel key.Binding
	Save   key.Binding
}

func newWizardKeyMap() wizardKeyMap {
	return wizardKeyMap{
		Next: key.NewBinding(
			key.WithKeys("tab", "enter"),
			key.WithHelp("tab/enter", "next"),
		),
		Back: key.NewBinding(
			key.WithKeys("shift+tab", "esc"),
			key.WithHelp("shift+tab/esc", "back"),
		),
		Cancel: key.NewBinding(
			key.WithKeys("ctrl+c"),
			key.WithHelp("ctrl+c", "cancel"),
		),
		Save: key.NewBinding(
			key.WithKeys("ctrl+s"),
			key.WithHelp("ctrl+s", "save"),
		),
	}
}

// Wizard is the main wizard struct for creating/editing profiles
type Wizard struct {
	step        int
	profileName string
	config      config.Config
	editMode    bool // true when editing existing profile, false when creating new

	// Sub-views for each step
	nameStep   WizardName
	agentsStep WizardAgents
	hooksStep  WizardHooks
	otherStep  WizardOther
	reviewStep WizardReview

	width  int
	height int
	keys   wizardKeyMap
	err    error
}

// NewWizard creates a new wizard for creating a profile
func NewWizard() Wizard {
	return Wizard{
		step:       StepName,
		config:     config.Config{},
		editMode:   false,
		nameStep:   NewWizardName(),
		agentsStep: NewWizardAgents(),
		hooksStep:  NewWizardHooks(),
		otherStep:  NewWizardOther(),
		reviewStep: NewWizardReview(),
		keys:       newWizardKeyMap(),
	}
}

// NewWizardForEdit creates a wizard for editing an existing profile
func NewWizardForEdit(p *profile.Profile) Wizard {
	w := NewWizard()
	w.editMode = true
	w.profileName = p.Name
	w.config = p.Config
	w.nameStep.SetName(p.Name)
	w.agentsStep.SetConfig(&w.config)
	w.hooksStep.SetConfig(&w.config)
	w.otherStep.SetConfig(&w.config)
	w.reviewStep.SetConfig(p.Name, &w.config)
	return w
}

func (w Wizard) Init() tea.Cmd {
	return w.nameStep.Init()
}

func (w *Wizard) SetSize(width, height int) {
	w.width = width
	w.height = height
	// Reserve space for header/footer
	contentHeight := height - 6
	w.nameStep.SetSize(width, contentHeight)
	w.agentsStep.SetSize(width, contentHeight)
	w.hooksStep.SetSize(width, contentHeight)
	w.otherStep.SetSize(width, contentHeight)
	w.reviewStep.SetSize(width, contentHeight)
}

func (w Wizard) Update(msg tea.Msg) (Wizard, tea.Cmd) {
	var cmd tea.Cmd
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		w.SetSize(msg.Width, msg.Height)
		return w, nil

	case WizardNextMsg:
		return w.nextStep()

	case WizardBackMsg:
		return w.prevStep()

	case WizardCancelMsg:
		return w, func() tea.Msg { return NavigateToDashboardMsg{} }

	case WizardSaveMsg:
		return w, func() tea.Msg { return NavigateToDashboardMsg{} }

	case tea.KeyMsg:
		// Global navigation keys
		if key.Matches(msg, w.keys.Cancel) {
			return w, func() tea.Msg { return WizardCancelMsg{} }
		}
	}

	// Delegate to current step
	switch w.step {
	case StepName:
		w.nameStep, cmd = w.nameStep.Update(msg)
		cmds = append(cmds, cmd)
		// Check for step completion
		if w.nameStep.IsComplete() {
			w.profileName = w.nameStep.GetName()
		}

	case StepAgents:
		w.agentsStep, cmd = w.agentsStep.Update(msg)
		cmds = append(cmds, cmd)

	case StepHooks:
		w.hooksStep, cmd = w.hooksStep.Update(msg)
		cmds = append(cmds, cmd)

	case StepOther:
		w.otherStep, cmd = w.otherStep.Update(msg)
		cmds = append(cmds, cmd)

	case StepReview:
		w.reviewStep, cmd = w.reviewStep.Update(msg)
		cmds = append(cmds, cmd)
	}

	return w, tea.Batch(cmds...)
}

func (w Wizard) nextStep() (Wizard, tea.Cmd) {
	switch w.step {
	case StepName:
		if !w.nameStep.IsComplete() {
			return w, nil
		}
		w.profileName = w.nameStep.GetName()
		w.step = StepAgents
		w.agentsStep.SetConfig(&w.config)
		return w, w.agentsStep.Init()

	case StepAgents:
		w.agentsStep.Apply(&w.config)
		w.step = StepHooks
		w.hooksStep.SetConfig(&w.config)
		return w, w.hooksStep.Init()

	case StepHooks:
		w.hooksStep.Apply(&w.config)
		w.step = StepOther
		w.otherStep.SetConfig(&w.config)
		return w, w.otherStep.Init()

	case StepOther:
		w.otherStep.Apply(&w.config)
		w.step = StepReview
		w.reviewStep.SetConfig(w.profileName, &w.config)
		return w, w.reviewStep.Init()

	case StepReview:
		// Save profile
		p := &profile.Profile{
			Name:   w.profileName,
			Config: w.config,
		}
		if err := profile.Save(p); err != nil {
			w.err = err
			return w, nil
		}
		return w, func() tea.Msg { return WizardSaveMsg{Profile: p} }
	}
	return w, nil
}

func (w Wizard) prevStep() (Wizard, tea.Cmd) {
	switch w.step {
	case StepName:
		return w, func() tea.Msg { return WizardCancelMsg{} }
	case StepAgents:
		w.step = StepName
		return w, w.nameStep.Init()
	case StepHooks:
		w.step = StepAgents
		return w, w.agentsStep.Init()
	case StepOther:
		w.step = StepHooks
		return w, w.hooksStep.Init()
	case StepReview:
		w.step = StepOther
		return w, w.otherStep.Init()
	}
	return w, nil
}

func (w Wizard) View() string {
	// Header with progress indicator
	header := w.renderHeader()

	// Current step content
	var content string
	switch w.step {
	case StepName:
		content = w.nameStep.View()
	case StepAgents:
		content = w.agentsStep.View()
	case StepHooks:
		content = w.hooksStep.View()
	case StepOther:
		content = w.otherStep.View()
	case StepReview:
		content = w.reviewStep.View()
	}

	// Footer with navigation help
	footer := w.renderFooter()

	return lipgloss.JoinVertical(lipgloss.Left,
		header,
		"",
		content,
		"",
		footer,
	)
}

func (w Wizard) renderHeader() string {
	// Progress bar
	progressStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#7D56F4"))
	dimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#6C7086"))

	var steps []string
	for i := StepName; i <= StepReview; i++ {
		stepNum := lipgloss.NewStyle().Bold(i == w.step)
		if i == w.step {
			steps = append(steps, progressStyle.Render(stepNum.Render(stepNames[i])))
		} else if i < w.step {
			steps = append(steps, successStyle.Render("✓ "+stepNames[i]))
		} else {
			steps = append(steps, dimStyle.Render(stepNames[i]))
		}
	}

	progress := lipgloss.JoinHorizontal(lipgloss.Top,
		steps[0], dimStyle.Render(" → "),
		steps[1], dimStyle.Render(" → "),
		steps[2], dimStyle.Render(" → "),
		steps[3], dimStyle.Render(" → "),
		steps[4],
	)

	title := titleStyle.Render("Create Profile")
	if w.editMode {
		title = titleStyle.Render("Edit Profile")
	}

	return lipgloss.JoinVertical(lipgloss.Left, title, progress)
}

func (w Wizard) renderFooter() string {
	helpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#6C7086"))

	var helpParts []string

	if w.step == StepName {
		helpParts = append(helpParts, "esc cancel")
	} else {
		helpParts = append(helpParts, "shift+tab back")
	}

	if w.step == StepReview {
		helpParts = append(helpParts, "enter save")
	} else {
		helpParts = append(helpParts, "tab/enter next")
	}

	helpParts = append(helpParts, "ctrl+c cancel")

	if w.err != nil {
		errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#F38BA8"))
		return lipgloss.JoinVertical(lipgloss.Left,
			errorStyle.Render("Error: "+w.err.Error()),
			helpStyle.Render(lipgloss.JoinHorizontal(lipgloss.Top, helpParts...)),
		)
	}

	return helpStyle.Render(lipgloss.JoinHorizontal(lipgloss.Top,
		helpParts[0], " • ", helpParts[1], " • ", helpParts[2]))
}

// GetProfile returns the built profile
func (w Wizard) GetProfile() *profile.Profile {
	return &profile.Profile{
		Name:   w.profileName,
		Config: w.config,
	}
}

// IsEditMode returns true if editing an existing profile
func (w Wizard) IsEditMode() bool {
	return w.editMode
}
</file>
<file path="internal/tui/views/wizard_agents.go">
package views

import (
	"fmt"
	"strconv"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/textarea"
	"github.com/charmbracelet/bubbles/textinput"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/diogenes/omo-profiler/internal/config"
)

// All 15 agents
var allAgents = []string{
	"build",
	"plan",
	"Sisyphus",
	"Sisyphus-Junior",
	"OpenCode-Builder",
	"Prometheus (Planner)",
	"Metis (Plan Consultant)",
	"Momus (Plan Reviewer)",
	"oracle",
	"librarian",
	"explore",
	"frontend-ui-ux-engineer",
	"document-writer",
	"multimodal-looker",
	"orchestrator-sisyphus",
}

// Mode options for agents
var agentModes = []string{"", "subagent", "primary", "all"}

// Permission values
var permissionValues = []string{"", "ask", "allow", "deny"}

type agentFormField int

const (
	fieldModel agentFormField = iota
	fieldVariant
	fieldCategory
	fieldTemperature
	fieldTopP
	fieldSkills
	fieldPrompt
	fieldPromptAppend
	fieldDisable
	fieldDescription
	fieldMode
	fieldColor
	fieldPermEdit
	fieldPermBash
	fieldPermWebfetch
	fieldPermDoomLoop
	fieldPermExtDir
)

type agentConfig struct {
	enabled      bool
	expanded     bool
	model        textinput.Model
	variant      textinput.Model
	category     textinput.Model
	temperature  textinput.Model
	topP         textinput.Model
	skills       textinput.Model
	prompt       textarea.Model
	promptAppend textarea.Model
	disable      bool
	description  textinput.Model
	modeIdx      int
	color        textinput.Model
	// Permissions
	permEditIdx     int
	permBashIdx     int
	permWebfetchIdx int
	permDoomLoopIdx int
	permExtDirIdx   int
}

func newAgentConfig() agentConfig {
	model := textinput.New()
	model.Placeholder = "model name"
	model.Width = 30

	variant := textinput.New()
	variant.Placeholder = "variant"
	variant.Width = 30

	category := textinput.New()
	category.Placeholder = "category"
	category.Width = 30

	temperature := textinput.New()
	temperature.Placeholder = "0.0-2.0"
	temperature.Width = 10

	topP := textinput.New()
	topP.Placeholder = "0.0-1.0"
	topP.Width = 10

	skills := textinput.New()
	skills.Placeholder = "skill1, skill2"
	skills.Width = 40

	prompt := textarea.New()
	prompt.Placeholder = "Custom prompt..."
	prompt.SetWidth(50)
	prompt.SetHeight(3)

	promptAppend := textarea.New()
	promptAppend.Placeholder = "Append to prompt..."
	promptAppend.SetWidth(50)
	promptAppend.SetHeight(3)

	description := textinput.New()
	description.Placeholder = "description"
	description.Width = 40

	color := textinput.New()
	color.Placeholder = "#RRGGBB"
	color.Width = 10

	return agentConfig{
		model:        model,
		variant:      variant,
		category:     category,
		temperature:  temperature,
		topP:         topP,
		skills:       skills,
		prompt:       prompt,
		promptAppend: promptAppend,
		description:  description,
		color:        color,
	}
}

type wizardAgentsKeyMap struct {
	Up       key.Binding
	Down     key.Binding
	Toggle   key.Binding
	Expand   key.Binding
	Next     key.Binding
	Back     key.Binding
	Tab      key.Binding
	ShiftTab key.Binding
}

func newWizardAgentsKeyMap() wizardAgentsKeyMap {
	return wizardAgentsKeyMap{
		Up: key.NewBinding(
			key.WithKeys("up", "k"),
			key.WithHelp("↑/k", "up"),
		),
		Down: key.NewBinding(
			key.WithKeys("down", "j"),
			key.WithHelp("↓/j", "down"),
		),
		Toggle: key.NewBinding(
			key.WithKeys(" "),
			key.WithHelp("space", "toggle"),
		),
		Expand: key.NewBinding(
			key.WithKeys("enter"),
			key.WithHelp("enter", "expand/collapse"),
		),
		Next: key.NewBinding(
			key.WithKeys("tab"),
			key.WithHelp("tab", "next step"),
		),
		Back: key.NewBinding(
			key.WithKeys("shift+tab"),
			key.WithHelp("shift+tab", "back"),
		),
		Tab: key.NewBinding(
			key.WithKeys("tab"),
			key.WithHelp("tab", "next field"),
		),
		ShiftTab: key.NewBinding(
			key.WithKeys("shift+tab"),
			key.WithHelp("shift+tab", "prev field"),
		),
	}
}

// WizardAgents is step 2: Agent configuration
type WizardAgents struct {
	agents       map[string]*agentConfig
	cursor       int
	focusedField agentFormField
	inForm       bool // true when editing expanded agent form
	viewport     viewport.Model
	ready        bool
	width        int
	height       int
	keys         wizardAgentsKeyMap
}

func NewWizardAgents() WizardAgents {
	agents := make(map[string]*agentConfig)
	for _, name := range allAgents {
		cfg := newAgentConfig()
		agents[name] = &cfg
	}

	return WizardAgents{
		agents: agents,
		keys:   newWizardAgentsKeyMap(),
	}
}

func (w WizardAgents) Init() tea.Cmd {
	return nil
}

func (w *WizardAgents) SetSize(width, height int) {
	w.width = width
	w.height = height
	if !w.ready {
		w.viewport = viewport.New(width, height-4)
		w.ready = true
	} else {
		w.viewport.Width = width
		w.viewport.Height = height - 4
	}
}

func (w *WizardAgents) SetConfig(cfg *config.Config) {
	if cfg.Agents == nil {
		return
	}
	for name, agentCfg := range cfg.Agents {
		if ac, ok := w.agents[name]; ok {
			ac.enabled = true
			if agentCfg.Model != "" {
				ac.model.SetValue(agentCfg.Model)
			}
			if agentCfg.Variant != "" {
				ac.variant.SetValue(agentCfg.Variant)
			}
			if agentCfg.Category != "" {
				ac.category.SetValue(agentCfg.Category)
			}
			if agentCfg.Temperature != nil {
				ac.temperature.SetValue(fmt.Sprintf("%.1f", *agentCfg.Temperature))
			}
			if agentCfg.TopP != nil {
				ac.topP.SetValue(fmt.Sprintf("%.1f", *agentCfg.TopP))
			}
			if agentCfg.Prompt != "" {
				ac.prompt.SetValue(agentCfg.Prompt)
			}
			if agentCfg.PromptAppend != "" {
				ac.promptAppend.SetValue(agentCfg.PromptAppend)
			}
			if agentCfg.Disable != nil && *agentCfg.Disable {
				ac.disable = true
			}
			if agentCfg.Description != "" {
				ac.description.SetValue(agentCfg.Description)
			}
			if agentCfg.Mode != "" {
				for i, m := range agentModes {
					if m == agentCfg.Mode {
						ac.modeIdx = i
						break
					}
				}
			}
			if agentCfg.Color != "" {
				ac.color.SetValue(agentCfg.Color)
			}
			// Permissions
			if agentCfg.Permission != nil {
				for i, v := range permissionValues {
					if v == agentCfg.Permission.Edit {
						ac.permEditIdx = i
					}
					if bashStr, ok := agentCfg.Permission.Bash.(string); ok && v == bashStr {
						ac.permBashIdx = i
					}
					if v == agentCfg.Permission.Webfetch {
						ac.permWebfetchIdx = i
					}
					if v == agentCfg.Permission.DoomLoop {
						ac.permDoomLoopIdx = i
					}
					if v == agentCfg.Permission.ExternalDirectory {
						ac.permExtDirIdx = i
					}
				}
			}
		}
	}
}

func (w *WizardAgents) Apply(cfg *config.Config) {
	if cfg.Agents == nil {
		cfg.Agents = make(map[string]*config.AgentConfig)
	}

	for name, ac := range w.agents {
		if !ac.enabled {
			delete(cfg.Agents, name)
			continue
		}

		agentCfg := &config.AgentConfig{}

		if v := ac.model.Value(); v != "" {
			agentCfg.Model = v
		}
		if v := ac.variant.Value(); v != "" {
			agentCfg.Variant = v
		}
		if v := ac.category.Value(); v != "" {
			agentCfg.Category = v
		}
		if v := ac.temperature.Value(); v != "" {
			if f, err := strconv.ParseFloat(v, 64); err == nil {
				agentCfg.Temperature = &f
			}
		}
		if v := ac.topP.Value(); v != "" {
			if f, err := strconv.ParseFloat(v, 64); err == nil {
				agentCfg.TopP = &f
			}
		}
		if v := ac.prompt.Value(); v != "" {
			agentCfg.Prompt = v
		}
		if v := ac.promptAppend.Value(); v != "" {
			agentCfg.PromptAppend = v
		}
		if ac.disable {
			b := true
			agentCfg.Disable = &b
		}
		if v := ac.description.Value(); v != "" {
			agentCfg.Description = v
		}
		if ac.modeIdx > 0 {
			agentCfg.Mode = agentModes[ac.modeIdx]
		}
		if v := ac.color.Value(); v != "" {
			agentCfg.Color = v
		}

		// Permissions
		if ac.permEditIdx > 0 || ac.permBashIdx > 0 || ac.permWebfetchIdx > 0 ||
			ac.permDoomLoopIdx > 0 || ac.permExtDirIdx > 0 {
			agentCfg.Permission = &config.PermissionConfig{}
			if ac.permEditIdx > 0 {
				agentCfg.Permission.Edit = permissionValues[ac.permEditIdx]
			}
			if ac.permBashIdx > 0 {
				agentCfg.Permission.Bash = permissionValues[ac.permBashIdx]
			}
			if ac.permWebfetchIdx > 0 {
				agentCfg.Permission.Webfetch = permissionValues[ac.permWebfetchIdx]
			}
			if ac.permDoomLoopIdx > 0 {
				agentCfg.Permission.DoomLoop = permissionValues[ac.permDoomLoopIdx]
			}
			if ac.permExtDirIdx > 0 {
				agentCfg.Permission.ExternalDirectory = permissionValues[ac.permExtDirIdx]
			}
		}

		cfg.Agents[name] = agentCfg
	}

	// Remove empty agents map
	if len(cfg.Agents) == 0 {
		cfg.Agents = nil
	}
}

func (w WizardAgents) Update(msg tea.Msg) (WizardAgents, tea.Cmd) {
	var cmd tea.Cmd
	var cmds []tea.Cmd

	currentAgent := allAgents[w.cursor]
	ac := w.agents[currentAgent]

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		w.SetSize(msg.Width, msg.Height)
		return w, nil

	case tea.KeyMsg:
		// When in form editing mode
		if w.inForm && ac.expanded {
			switch msg.String() {
			case "esc":
				w.inForm = false
				return w, nil
			case "tab":
				w.focusedField++
				if w.focusedField > fieldPermExtDir {
					w.focusedField = fieldModel
				}
				return w, nil
			case "shift+tab":
				if w.focusedField == fieldModel {
					w.focusedField = fieldPermExtDir
				} else {
					w.focusedField--
				}
				return w, nil
			case "left", "right":
				// Cycle through options for dropdown fields
				switch w.focusedField {
				case fieldDisable:
					ac.disable = !ac.disable
				case fieldMode:
					if msg.String() == "right" {
						ac.modeIdx = (ac.modeIdx + 1) % len(agentModes)
					} else {
						ac.modeIdx = (ac.modeIdx - 1 + len(agentModes)) % len(agentModes)
					}
				case fieldPermEdit:
					if msg.String() == "right" {
						ac.permEditIdx = (ac.permEditIdx + 1) % len(permissionValues)
					} else {
						ac.permEditIdx = (ac.permEditIdx - 1 + len(permissionValues)) % len(permissionValues)
					}
				case fieldPermBash:
					if msg.String() == "right" {
						ac.permBashIdx = (ac.permBashIdx + 1) % len(permissionValues)
					} else {
						ac.permBashIdx = (ac.permBashIdx - 1 + len(permissionValues)) % len(permissionValues)
					}
				case fieldPermWebfetch:
					if msg.String() == "right" {
						ac.permWebfetchIdx = (ac.permWebfetchIdx + 1) % len(permissionValues)
					} else {
						ac.permWebfetchIdx = (ac.permWebfetchIdx - 1 + len(permissionValues)) % len(permissionValues)
					}
				case fieldPermDoomLoop:
					if msg.String() == "right" {
						ac.permDoomLoopIdx = (ac.permDoomLoopIdx + 1) % len(permissionValues)
					} else {
						ac.permDoomLoopIdx = (ac.permDoomLoopIdx - 1 + len(permissionValues)) % len(permissionValues)
					}
				case fieldPermExtDir:
					if msg.String() == "right" {
						ac.permExtDirIdx = (ac.permExtDirIdx + 1) % len(permissionValues)
					} else {
						ac.permExtDirIdx = (ac.permExtDirIdx - 1 + len(permissionValues)) % len(permissionValues)
					}
				}
				return w, nil
			}

			// Update focused text input
			switch w.focusedField {
			case fieldModel:
				ac.model.Focus()
				ac.model, cmd = ac.model.Update(msg)
				cmds = append(cmds, cmd)
			case fieldVariant:
				ac.variant.Focus()
				ac.variant, cmd = ac.variant.Update(msg)
				cmds = append(cmds, cmd)
			case fieldCategory:
				ac.category.Focus()
				ac.category, cmd = ac.category.Update(msg)
				cmds = append(cmds, cmd)
			case fieldTemperature:
				ac.temperature.Focus()
				ac.temperature, cmd = ac.temperature.Update(msg)
				cmds = append(cmds, cmd)
			case fieldTopP:
				ac.topP.Focus()
				ac.topP, cmd = ac.topP.Update(msg)
				cmds = append(cmds, cmd)
			case fieldSkills:
				ac.skills.Focus()
				ac.skills, cmd = ac.skills.Update(msg)
				cmds = append(cmds, cmd)
			case fieldPrompt:
				ac.prompt.Focus()
				ac.prompt, cmd = ac.prompt.Update(msg)
				cmds = append(cmds, cmd)
			case fieldPromptAppend:
				ac.promptAppend.Focus()
				ac.promptAppend, cmd = ac.promptAppend.Update(msg)
				cmds = append(cmds, cmd)
			case fieldDescription:
				ac.description.Focus()
				ac.description, cmd = ac.description.Update(msg)
				cmds = append(cmds, cmd)
			case fieldColor:
				ac.color.Focus()
				ac.color, cmd = ac.color.Update(msg)
				cmds = append(cmds, cmd)
			}

			return w, tea.Batch(cmds...)
		}

		// Navigation mode
		switch {
		case key.Matches(msg, w.keys.Up):
			if w.cursor > 0 {
				w.cursor--
			}
		case key.Matches(msg, w.keys.Down):
			if w.cursor < len(allAgents)-1 {
				w.cursor++
			}
		case key.Matches(msg, w.keys.Toggle):
			ac.enabled = !ac.enabled
		case key.Matches(msg, w.keys.Expand):
			if ac.enabled {
				ac.expanded = !ac.expanded
				if ac.expanded {
					w.inForm = true
					w.focusedField = fieldModel
				}
			}
		case key.Matches(msg, w.keys.Next):
			if !w.inForm {
				return w, func() tea.Msg { return WizardNextMsg{} }
			}
		case key.Matches(msg, w.keys.Back):
			if !w.inForm {
				return w, func() tea.Msg { return WizardBackMsg{} }
			}
		}
	}

	// Update viewport
	w.viewport.SetContent(w.renderContent())
	w.viewport, cmd = w.viewport.Update(msg)
	cmds = append(cmds, cmd)

	return w, tea.Batch(cmds...)
}

func (w WizardAgents) renderContent() string {
	var lines []string

	labelStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#CDD6F4"))
	dimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#6C7086"))
	selectedStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#7D56F4"))
	enabledStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#A6E3A1"))

	for i, name := range allAgents {
		ac := w.agents[name]

		cursor := "  "
		if i == w.cursor {
			cursor = selectedStyle.Render("> ")
		}

		checkbox := "[ ]"
		if ac.enabled {
			checkbox = enabledStyle.Render("[✓]")
		}

		expandIcon := ""
		if ac.enabled {
			if ac.expanded {
				expandIcon = " ▼"
			} else {
				expandIcon = " ▶"
			}
		}

		nameStyle := dimStyle
		if i == w.cursor {
			nameStyle = labelStyle
		}

		line := fmt.Sprintf("%s%s %s%s", cursor, checkbox, nameStyle.Render(name), expandIcon)
		lines = append(lines, line)

		// Show expanded form
		if ac.expanded && ac.enabled {
			lines = append(lines, w.renderAgentForm(name, ac)...)
		}
	}

	return lipgloss.JoinVertical(lipgloss.Left, lines...)
}

func (w WizardAgents) renderAgentForm(name string, ac *agentConfig) []string {
	var lines []string

	indent := "      "
	fieldStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#6C7086"))
	focusStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#7D56F4"))

	renderField := func(label string, field agentFormField, value string) string {
		style := fieldStyle
		if w.inForm && w.focusedField == field {
			style = focusStyle
		}
		return indent + style.Render(fmt.Sprintf("%-12s: ", label)) + value
	}

	renderDropdown := func(label string, field agentFormField, options []string, idx int) string {
		style := fieldStyle
		if w.inForm && w.focusedField == field {
			style = focusStyle
		}
		val := "(none)"
		if idx > 0 && idx < len(options) {
			val = options[idx]
		}
		return indent + style.Render(fmt.Sprintf("%-12s: ", label)) + val + " [←/→]"
	}

	renderBool := func(label string, field agentFormField, val bool) string {
		style := fieldStyle
		if w.inForm && w.focusedField == field {
			style = focusStyle
		}
		checkbox := "[ ]"
		if val {
			checkbox = "[✓]"
		}
		return indent + style.Render(fmt.Sprintf("%-12s: ", label)) + checkbox + " [←/→]"
	}

	lines = append(lines, "")
	lines = append(lines, renderField("model", fieldModel, ac.model.View()))
	lines = append(lines, renderField("variant", fieldVariant, ac.variant.View()))
	lines = append(lines, renderField("category", fieldCategory, ac.category.View()))
	lines = append(lines, renderField("temperature", fieldTemperature, ac.temperature.View()))
	lines = append(lines, renderField("top_p", fieldTopP, ac.topP.View()))
	lines = append(lines, renderField("skills", fieldSkills, ac.skills.View()))
	lines = append(lines, renderField("prompt", fieldPrompt, ac.prompt.View()))
	lines = append(lines, renderField("prompt_append", fieldPromptAppend, ac.promptAppend.View()))
	lines = append(lines, renderBool("disable", fieldDisable, ac.disable))
	lines = append(lines, renderField("description", fieldDescription, ac.description.View()))
	lines = append(lines, renderDropdown("mode", fieldMode, agentModes, ac.modeIdx))
	lines = append(lines, renderField("color", fieldColor, ac.color.View()))
	lines = append(lines, "")
	lines = append(lines, indent+fieldStyle.Render("── Permissions ──"))
	lines = append(lines, renderDropdown("edit", fieldPermEdit, permissionValues, ac.permEditIdx))
	lines = append(lines, renderDropdown("bash", fieldPermBash, permissionValues, ac.permBashIdx))
	lines = append(lines, renderDropdown("webfetch", fieldPermWebfetch, permissionValues, ac.permWebfetchIdx))
	lines = append(lines, renderDropdown("doom_loop", fieldPermDoomLoop, permissionValues, ac.permDoomLoopIdx))
	lines = append(lines, renderDropdown("external_dir", fieldPermExtDir, permissionValues, ac.permExtDirIdx))
	lines = append(lines, "")

	return lines
}

func (w WizardAgents) View() string {
	titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#CDD6F4"))
	helpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#6C7086"))

	title := titleStyle.Render("Configure Agents")
	desc := helpStyle.Render("Space to enable/disable • Enter to expand • Tab to next step")

	if w.inForm {
		desc = helpStyle.Render("Tab/Shift+Tab to navigate • ←/→ for options • Esc to close form")
	}

	content := w.viewport.View()

	return lipgloss.JoinVertical(lipgloss.Left,
		title,
		desc,
		"",
		content,
	)
}
</file>
<file path="internal/tui/views/wizard_hooks.go">
package views

import (
	"fmt"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/diogenes/omo-profiler/internal/config"
)

// All 31 hooks
var allHooks = []string{
	"todo-continuation-enforcer",
	"context-window-monitor",
	"session-recovery",
	"session-notification",
	"comment-checker",
	"grep-output-truncator",
	"tool-output-truncator",
	"directory-agents-injector",
	"directory-readme-injector",
	"empty-task-response-detector",
	"think-mode",
	"anthropic-context-window-limit-recovery",
	"rules-injector",
	"background-notification",
	"auto-update-checker",
	"startup-toast",
	"keyword-detector",
	"agent-usage-reminder",
	"non-interactive-env",
	"interactive-bash-session",
	"empty-message-sanitizer",
	"thinking-block-validator",
	"ralph-loop",
	"preemptive-compaction",
	"compaction-context-injector",
	"claude-code-hooks",
	"auto-slash-command",
	"edit-error-recovery",
	"prometheus-md-only",
	"start-work",
	"sisyphus-orchestrator",
}

type wizardHooksKeyMap struct {
	Up       key.Binding
	Down     key.Binding
	Toggle   key.Binding
	Next     key.Binding
	Back     key.Binding
	PageUp   key.Binding
	PageDown key.Binding
}

func newWizardHooksKeyMap() wizardHooksKeyMap {
	return wizardHooksKeyMap{
		Up: key.NewBinding(
			key.WithKeys("up", "k"),
			key.WithHelp("↑/k", "up"),
		),
		Down: key.NewBinding(
			key.WithKeys("down", "j"),
			key.WithHelp("↓/j", "down"),
		),
		Toggle: key.NewBinding(
			key.WithKeys(" ", "enter"),
			key.WithHelp("space/enter", "toggle"),
		),
		Next: key.NewBinding(
			key.WithKeys("tab"),
			key.WithHelp("tab", "next step"),
		),
		Back: key.NewBinding(
			key.WithKeys("shift+tab", "esc"),
			key.WithHelp("shift+tab/esc", "back"),
		),
		PageUp: key.NewBinding(
			key.WithKeys("pgup"),
			key.WithHelp("pgup", "page up"),
		),
		PageDown: key.NewBinding(
			key.WithKeys("pgdown"),
			key.WithHelp("pgdown", "page down"),
		),
	}
}

// WizardHooks is step 3: Hook configuration
type WizardHooks struct {
	disabled map[string]bool
	cursor   int
	viewport viewport.Model
	ready    bool
	width    int
	height   int
	keys     wizardHooksKeyMap
}

func NewWizardHooks() WizardHooks {
	disabled := make(map[string]bool)
	for _, hook := range allHooks {
		disabled[hook] = false // All enabled by default
	}

	return WizardHooks{
		disabled: disabled,
		keys:     newWizardHooksKeyMap(),
	}
}

func (w WizardHooks) Init() tea.Cmd {
	return nil
}

func (w *WizardHooks) SetSize(width, height int) {
	w.width = width
	w.height = height
	if !w.ready {
		w.viewport = viewport.New(width, height-4)
		w.ready = true
	} else {
		w.viewport.Width = width
		w.viewport.Height = height - 4
	}
}

func (w *WizardHooks) SetConfig(cfg *config.Config) {
	// Reset all to enabled
	for hook := range w.disabled {
		w.disabled[hook] = false
	}
	// Mark disabled ones
	for _, hook := range cfg.DisabledHooks {
		if _, ok := w.disabled[hook]; ok {
			w.disabled[hook] = true
		}
	}
}

func (w *WizardHooks) Apply(cfg *config.Config) {
	var disabled []string
	for _, hook := range allHooks {
		if w.disabled[hook] {
			disabled = append(disabled, hook)
		}
	}
	cfg.DisabledHooks = disabled
	if len(cfg.DisabledHooks) == 0 {
		cfg.DisabledHooks = nil
	}
}

func (w WizardHooks) Update(msg tea.Msg) (WizardHooks, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		w.SetSize(msg.Width, msg.Height)
		return w, nil

	case tea.KeyMsg:
		switch {
		case key.Matches(msg, w.keys.Up):
			if w.cursor > 0 {
				w.cursor--
			}
		case key.Matches(msg, w.keys.Down):
			if w.cursor < len(allHooks)-1 {
				w.cursor++
			}
		case key.Matches(msg, w.keys.Toggle):
			hook := allHooks[w.cursor]
			w.disabled[hook] = !w.disabled[hook]
		case key.Matches(msg, w.keys.Next):
			return w, func() tea.Msg { return WizardNextMsg{} }
		case key.Matches(msg, w.keys.Back):
			return w, func() tea.Msg { return WizardBackMsg{} }
		case key.Matches(msg, w.keys.PageUp):
			w.cursor -= 10
			if w.cursor < 0 {
				w.cursor = 0
			}
		case key.Matches(msg, w.keys.PageDown):
			w.cursor += 10
			if w.cursor >= len(allHooks) {
				w.cursor = len(allHooks) - 1
			}
		}
	}

	// Update viewport content
	w.viewport.SetContent(w.renderContent())
	w.viewport, cmd = w.viewport.Update(msg)

	return w, cmd
}

func (w WizardHooks) renderContent() string {
	var lines []string

	selectedStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#7D56F4"))
	enabledStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#A6E3A1"))
	disabledStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#F38BA8"))
	dimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#6C7086"))

	for i, hook := range allHooks {
		cursor := "  "
		if i == w.cursor {
			cursor = selectedStyle.Render("> ")
		}

		var checkbox string
		if w.disabled[hook] {
			checkbox = disabledStyle.Render("[✗]")
		} else {
			checkbox = enabledStyle.Render("[✓]")
		}

		nameStyle := dimStyle
		if i == w.cursor {
			nameStyle = lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#CDD6F4"))
		}

		status := ""
		if w.disabled[hook] {
			status = disabledStyle.Render(" (disabled)")
		}

		line := fmt.Sprintf("%s%s %s%s", cursor, checkbox, nameStyle.Render(hook), status)
		lines = append(lines, line)
	}

	return lipgloss.JoinVertical(lipgloss.Left, lines...)
}

func (w WizardHooks) View() string {
	titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#CDD6F4"))
	helpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#6C7086"))

	title := titleStyle.Render("Configure Hooks")
	desc := helpStyle.Render("Space/Enter to toggle • ✓ enabled • ✗ disabled • Tab next • Shift+Tab back")

	disabledCount := 0
	for _, d := range w.disabled {
		if d {
			disabledCount++
		}
	}
	stats := helpStyle.Render(fmt.Sprintf("%d/%d hooks disabled", disabledCount, len(allHooks)))

	content := w.viewport.View()

	return lipgloss.JoinVertical(lipgloss.Left,
		title,
		desc,
		stats,
		"",
		content,
	)
}
</file>
<file path="internal/tui/views/wizard_name.go">
package views

import (
	"fmt"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/diogenes/omo-profiler/internal/profile"
)

type wizardNameKeyMap struct {
	Next   key.Binding
	Cancel key.Binding
}

func newWizardNameKeyMap() wizardNameKeyMap {
	return wizardNameKeyMap{
		Next: key.NewBinding(
			key.WithKeys("tab", "enter"),
			key.WithHelp("tab/enter", "next"),
		),
		Cancel: key.NewBinding(
			key.WithKeys("esc"),
			key.WithHelp("esc", "cancel"),
		),
	}
}

// WizardName is step 1: Profile name input
type WizardName struct {
	input  textinput.Model
	name   string
	err    error
	valid  bool
	width  int
	height int
	keys   wizardNameKeyMap
}

func NewWizardName() WizardName {
	ti := textinput.New()
	ti.Placeholder = "my-profile"
	ti.Focus()
	ti.CharLimit = 64
	ti.Width = 40

	return WizardName{
		input: ti,
		keys:  newWizardNameKeyMap(),
	}
}

func (w WizardName) Init() tea.Cmd {
	return textinput.Blink
}

func (w *WizardName) SetSize(width, height int) {
	w.width = width
	w.height = height
}

func (w *WizardName) SetName(name string) {
	w.name = name
	w.input.SetValue(name)
	w.validate()
}

func (w *WizardName) validate() {
	name := w.input.Value()
	if name == "" {
		w.err = profile.ErrEmptyName
		w.valid = false
		return
	}
	if err := profile.ValidateName(name); err != nil {
		w.err = err
		w.valid = false
		return
	}
	w.err = nil
	w.valid = true
	w.name = name
}

func (w WizardName) Update(msg tea.Msg) (WizardName, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch {
		case key.Matches(msg, w.keys.Next):
			w.validate()
			if w.valid {
				return w, func() tea.Msg { return WizardNextMsg{} }
			}
			return w, nil

		case key.Matches(msg, w.keys.Cancel):
			return w, func() tea.Msg { return WizardCancelMsg{} }
		}
	}

	// Update text input
	w.input, cmd = w.input.Update(msg)
	w.validate()

	return w, cmd
}

func (w WizardName) View() string {
	labelStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("#CDD6F4"))

	descStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#6C7086"))

	errorStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#F38BA8"))

	validStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#A6E3A1"))

	label := labelStyle.Render("Profile Name")
	desc := descStyle.Render("Enter a name for your profile (letters, numbers, hyphens, underscores only)")

	input := w.input.View()

	var status string
	if w.input.Value() == "" {
		status = descStyle.Render("Required")
	} else if w.err != nil {
		status = errorStyle.Render(fmt.Sprintf("✗ %s", w.err.Error()))
	} else {
		status = validStyle.Render("✓ Valid name")
	}

	return lipgloss.JoinVertical(lipgloss.Left,
		label,
		desc,
		"",
		input,
		status,
	)
}

// IsComplete returns true if the name is valid
func (w WizardName) IsComplete() bool {
	return w.valid
}

// GetName returns the validated profile name
func (w WizardName) GetName() string {
	return w.name
}
</file>
<file path="internal/tui/views/wizard_other.go">
package views

import (
	"fmt"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/textinput"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/diogenes/omo-profiler/internal/config"
)

// Disableable agents (10)
var disableableAgents = []string{
	"Sisyphus",
	"oracle",
	"librarian",
	"explore",
	"frontend-ui-ux-engineer",
	"document-writer",
	"multimodal-looker",
	"Metis (Plan Consultant)",
	"Momus (Plan Reviewer)",
	"orchestrator-sisyphus",
}

// Disableable skills (3)
var disableableSkills = []string{
	"playwright",
	"frontend-ui-ux",
	"git-master",
}

// Disableable commands (2)
var disableableCommands = []string{
	"init-deep",
	"start-work",
}

// Sections in the other settings
type otherSection int

const (
	sectionDisabledMcps otherSection = iota
	sectionDisabledAgents
	sectionDisabledSkills
	sectionDisabledCommands
	sectionAutoUpdate
	sectionExperimental
	sectionClaudeCode
	sectionSisyphusAgent
	sectionRalphLoop
	sectionBackgroundTask
	sectionNotification
	sectionGitMaster
	sectionCommentChecker
)

var otherSectionNames = []string{
	"Disabled MCPs",
	"Disabled Agents",
	"Disabled Skills",
	"Disabled Commands",
	"Auto Update",
	"Experimental",
	"Claude Code",
	"Sisyphus Agent",
	"Ralph Loop",
	"Background Task",
	"Notification",
	"Git Master",
	"Comment Checker",
}

type wizardOtherKeyMap struct {
	Up     key.Binding
	Down   key.Binding
	Toggle key.Binding
	Expand key.Binding
	Next   key.Binding
	Back   key.Binding
	Left   key.Binding
	Right  key.Binding
}

func newWizardOtherKeyMap() wizardOtherKeyMap {
	return wizardOtherKeyMap{
		Up: key.NewBinding(
			key.WithKeys("up", "k"),
			key.WithHelp("↑/k", "up"),
		),
		Down: key.NewBinding(
			key.WithKeys("down", "j"),
			key.WithHelp("↓/j", "down"),
		),
		Toggle: key.NewBinding(
			key.WithKeys(" "),
			key.WithHelp("space", "toggle"),
		),
		Expand: key.NewBinding(
			key.WithKeys("enter"),
			key.WithHelp("enter", "expand/edit"),
		),
		Next: key.NewBinding(
			key.WithKeys("tab"),
			key.WithHelp("tab", "next step"),
		),
		Back: key.NewBinding(
			key.WithKeys("shift+tab", "esc"),
			key.WithHelp("shift+tab/esc", "back"),
		),
		Left: key.NewBinding(
			key.WithKeys("left", "h"),
			key.WithHelp("←/h", "prev option"),
		),
		Right: key.NewBinding(
			key.WithKeys("right", "l"),
			key.WithHelp("→/l", "next option"),
		),
	}
}

// WizardOther is step 4: Other settings
type WizardOther struct {
	// Disabled lists
	disabledMcps     textinput.Model
	disabledAgents   map[string]bool
	disabledSkills   map[string]bool
	disabledCommands map[string]bool

	// Auto update
	autoUpdate bool

	// Experimental flags
	expAggressiveTrunc    bool
	expAutoResume         bool
	expPreemptiveCompact  bool
	expTruncateAllOutputs bool
	expDcpForCompaction   bool

	// Claude Code
	ccMcp      bool
	ccCommands bool
	ccSkills   bool
	ccAgents   bool
	ccHooks    bool
	ccPlugins  bool

	// Sisyphus Agent
	saDisabled              bool
	saDefaultBuilderEnabled bool
	saPlannerEnabled        bool
	saReplacePlan           bool

	// Ralph Loop
	rlEnabled              bool
	rlDefaultMaxIterations textinput.Model
	rlStateDir             textinput.Model

	// Background Task
	btDefaultConcurrency textinput.Model

	// Notification
	notifForceEnable bool

	// Git Master
	gmCommitFooter        bool
	gmIncludeCoAuthoredBy bool

	// Comment Checker
	ccCustomPrompt textinput.Model

	// UI State
	currentSection  otherSection
	sectionExpanded map[otherSection]bool
	subCursor       int
	inSubSection    bool
	viewport        viewport.Model
	ready           bool
	width           int
	height          int
	keys            wizardOtherKeyMap
}

func NewWizardOther() WizardOther {
	disabledMcps := textinput.New()
	disabledMcps.Placeholder = "mcp1, mcp2, ..."
	disabledMcps.Width = 50

	rlMaxIter := textinput.New()
	rlMaxIter.Placeholder = "10"
	rlMaxIter.Width = 10

	rlStateDir := textinput.New()
	rlStateDir.Placeholder = "/path/to/state"
	rlStateDir.Width = 40

	btConcurrency := textinput.New()
	btConcurrency.Placeholder = "4"
	btConcurrency.Width = 10

	ccPrompt := textinput.New()
	ccPrompt.Placeholder = "custom prompt..."
	ccPrompt.Width = 50

	// Initialize disabled maps
	disabledAgents := make(map[string]bool)
	for _, a := range disableableAgents {
		disabledAgents[a] = false
	}

	disabledSkills := make(map[string]bool)
	for _, s := range disableableSkills {
		disabledSkills[s] = false
	}

	disabledCommands := make(map[string]bool)
	for _, c := range disableableCommands {
		disabledCommands[c] = false
	}

	sectionExpanded := make(map[otherSection]bool)

	return WizardOther{
		disabledMcps:           disabledMcps,
		disabledAgents:         disabledAgents,
		disabledSkills:         disabledSkills,
		disabledCommands:       disabledCommands,
		rlDefaultMaxIterations: rlMaxIter,
		rlStateDir:             rlStateDir,
		btDefaultConcurrency:   btConcurrency,
		ccCustomPrompt:         ccPrompt,
		sectionExpanded:        sectionExpanded,
		keys:                   newWizardOtherKeyMap(),
	}
}

func (w WizardOther) Init() tea.Cmd {
	return nil
}

func (w *WizardOther) SetSize(width, height int) {
	w.width = width
	w.height = height
	if !w.ready {
		w.viewport = viewport.New(width, height-4)
		w.ready = true
	} else {
		w.viewport.Width = width
		w.viewport.Height = height - 4
	}
}

func (w *WizardOther) SetConfig(cfg *config.Config) {
	// Disabled agents
	for _, a := range cfg.DisabledAgents {
		if _, ok := w.disabledAgents[a]; ok {
			w.disabledAgents[a] = true
		}
	}

	// Disabled skills
	for _, s := range cfg.DisabledSkills {
		if _, ok := w.disabledSkills[s]; ok {
			w.disabledSkills[s] = true
		}
	}

	// Disabled commands
	for _, c := range cfg.DisabledCommands {
		if _, ok := w.disabledCommands[c]; ok {
			w.disabledCommands[c] = true
		}
	}

	// Auto update
	if cfg.AutoUpdate != nil {
		w.autoUpdate = *cfg.AutoUpdate
	}

	// Experimental
	if cfg.Experimental != nil {
		if cfg.Experimental.AggressiveTruncation != nil {
			w.expAggressiveTrunc = *cfg.Experimental.AggressiveTruncation
		}
		if cfg.Experimental.AutoResume != nil {
			w.expAutoResume = *cfg.Experimental.AutoResume
		}
		if cfg.Experimental.PreemptiveCompaction != nil {
			w.expPreemptiveCompact = *cfg.Experimental.PreemptiveCompaction
		}
		if cfg.Experimental.TruncateAllToolOutputs != nil {
			w.expTruncateAllOutputs = *cfg.Experimental.TruncateAllToolOutputs
		}
		if cfg.Experimental.DcpForCompaction != nil {
			w.expDcpForCompaction = *cfg.Experimental.DcpForCompaction
		}
	}

	// Claude Code
	if cfg.ClaudeCode != nil {
		if cfg.ClaudeCode.MCP != nil {
			w.ccMcp = *cfg.ClaudeCode.MCP
		}
		if cfg.ClaudeCode.Commands != nil {
			w.ccCommands = *cfg.ClaudeCode.Commands
		}
		if cfg.ClaudeCode.Skills != nil {
			w.ccSkills = *cfg.ClaudeCode.Skills
		}
		if cfg.ClaudeCode.Agents != nil {
			w.ccAgents = *cfg.ClaudeCode.Agents
		}
		if cfg.ClaudeCode.Hooks != nil {
			w.ccHooks = *cfg.ClaudeCode.Hooks
		}
		if cfg.ClaudeCode.Plugins != nil {
			w.ccPlugins = *cfg.ClaudeCode.Plugins
		}
	}

	// Sisyphus Agent
	if cfg.SisyphusAgent != nil {
		if cfg.SisyphusAgent.Disabled != nil {
			w.saDisabled = *cfg.SisyphusAgent.Disabled
		}
		if cfg.SisyphusAgent.DefaultBuilderEnabled != nil {
			w.saDefaultBuilderEnabled = *cfg.SisyphusAgent.DefaultBuilderEnabled
		}
		if cfg.SisyphusAgent.PlannerEnabled != nil {
			w.saPlannerEnabled = *cfg.SisyphusAgent.PlannerEnabled
		}
		if cfg.SisyphusAgent.ReplacePlan != nil {
			w.saReplacePlan = *cfg.SisyphusAgent.ReplacePlan
		}
	}

	// Ralph Loop
	if cfg.RalphLoop != nil {
		if cfg.RalphLoop.Enabled != nil {
			w.rlEnabled = *cfg.RalphLoop.Enabled
		}
		if cfg.RalphLoop.DefaultMaxIterations != nil {
			w.rlDefaultMaxIterations.SetValue(fmt.Sprintf("%d", *cfg.RalphLoop.DefaultMaxIterations))
		}
		if cfg.RalphLoop.StateDir != "" {
			w.rlStateDir.SetValue(cfg.RalphLoop.StateDir)
		}
	}

	// Background Task
	if cfg.BackgroundTask != nil {
		if cfg.BackgroundTask.DefaultConcurrency != nil {
			w.btDefaultConcurrency.SetValue(fmt.Sprintf("%d", *cfg.BackgroundTask.DefaultConcurrency))
		}
	}

	// Notification
	if cfg.Notification != nil {
		if cfg.Notification.ForceEnable != nil {
			w.notifForceEnable = *cfg.Notification.ForceEnable
		}
	}

	// Git Master
	if cfg.GitMaster != nil {
		if cfg.GitMaster.CommitFooter != nil {
			w.gmCommitFooter = *cfg.GitMaster.CommitFooter
		}
		if cfg.GitMaster.IncludeCoAuthoredBy != nil {
			w.gmIncludeCoAuthoredBy = *cfg.GitMaster.IncludeCoAuthoredBy
		}
	}

	// Comment Checker
	if cfg.CommentChecker != nil {
		if cfg.CommentChecker.CustomPrompt != "" {
			w.ccCustomPrompt.SetValue(cfg.CommentChecker.CustomPrompt)
		}
	}
}

func (w *WizardOther) Apply(cfg *config.Config) {
	// Disabled agents
	var agents []string
	for _, a := range disableableAgents {
		if w.disabledAgents[a] {
			agents = append(agents, a)
		}
	}
	cfg.DisabledAgents = agents
	if len(cfg.DisabledAgents) == 0 {
		cfg.DisabledAgents = nil
	}

	// Disabled skills
	var skills []string
	for _, s := range disableableSkills {
		if w.disabledSkills[s] {
			skills = append(skills, s)
		}
	}
	cfg.DisabledSkills = skills
	if len(cfg.DisabledSkills) == 0 {
		cfg.DisabledSkills = nil
	}

	// Disabled commands
	var commands []string
	for _, c := range disableableCommands {
		if w.disabledCommands[c] {
			commands = append(commands, c)
		}
	}
	cfg.DisabledCommands = commands
	if len(cfg.DisabledCommands) == 0 {
		cfg.DisabledCommands = nil
	}

	// Auto update
	if w.autoUpdate {
		cfg.AutoUpdate = &w.autoUpdate
	}

	// Experimental - only set if any flag is true
	if w.expAggressiveTrunc || w.expAutoResume || w.expPreemptiveCompact ||
		w.expTruncateAllOutputs || w.expDcpForCompaction {
		cfg.Experimental = &config.ExperimentalConfig{}
		if w.expAggressiveTrunc {
			cfg.Experimental.AggressiveTruncation = &w.expAggressiveTrunc
		}
		if w.expAutoResume {
			cfg.Experimental.AutoResume = &w.expAutoResume
		}
		if w.expPreemptiveCompact {
			cfg.Experimental.PreemptiveCompaction = &w.expPreemptiveCompact
		}
		if w.expTruncateAllOutputs {
			cfg.Experimental.TruncateAllToolOutputs = &w.expTruncateAllOutputs
		}
		if w.expDcpForCompaction {
			cfg.Experimental.DcpForCompaction = &w.expDcpForCompaction
		}
	}

	// Claude Code - only set if any flag is true
	if w.ccMcp || w.ccCommands || w.ccSkills || w.ccAgents || w.ccHooks || w.ccPlugins {
		cfg.ClaudeCode = &config.ClaudeCodeConfig{}
		if w.ccMcp {
			cfg.ClaudeCode.MCP = &w.ccMcp
		}
		if w.ccCommands {
			cfg.ClaudeCode.Commands = &w.ccCommands
		}
		if w.ccSkills {
			cfg.ClaudeCode.Skills = &w.ccSkills
		}
		if w.ccAgents {
			cfg.ClaudeCode.Agents = &w.ccAgents
		}
		if w.ccHooks {
			cfg.ClaudeCode.Hooks = &w.ccHooks
		}
		if w.ccPlugins {
			cfg.ClaudeCode.Plugins = &w.ccPlugins
		}
	}

	// Sisyphus Agent - only set if any flag is true
	if w.saDisabled || w.saDefaultBuilderEnabled || w.saPlannerEnabled || w.saReplacePlan {
		cfg.SisyphusAgent = &config.SisyphusAgentConfig{}
		if w.saDisabled {
			cfg.SisyphusAgent.Disabled = &w.saDisabled
		}
		if w.saDefaultBuilderEnabled {
			cfg.SisyphusAgent.DefaultBuilderEnabled = &w.saDefaultBuilderEnabled
		}
		if w.saPlannerEnabled {
			cfg.SisyphusAgent.PlannerEnabled = &w.saPlannerEnabled
		}
		if w.saReplacePlan {
			cfg.SisyphusAgent.ReplacePlan = &w.saReplacePlan
		}
	}

	// Ralph Loop
	if w.rlEnabled || w.rlDefaultMaxIterations.Value() != "" || w.rlStateDir.Value() != "" {
		cfg.RalphLoop = &config.RalphLoopConfig{}
		if w.rlEnabled {
			cfg.RalphLoop.Enabled = &w.rlEnabled
		}
		if v := w.rlDefaultMaxIterations.Value(); v != "" {
			var i int
			fmt.Sscanf(v, "%d", &i)
			if i > 0 {
				cfg.RalphLoop.DefaultMaxIterations = &i
			}
		}
		if v := w.rlStateDir.Value(); v != "" {
			cfg.RalphLoop.StateDir = v
		}
	}

	// Background Task
	if v := w.btDefaultConcurrency.Value(); v != "" {
		var i int
		fmt.Sscanf(v, "%d", &i)
		if i > 0 {
			cfg.BackgroundTask = &config.BackgroundTaskConfig{
				DefaultConcurrency: &i,
			}
		}
	}

	// Notification
	if w.notifForceEnable {
		cfg.Notification = &config.NotificationConfig{
			ForceEnable: &w.notifForceEnable,
		}
	}

	// Git Master
	if w.gmCommitFooter || w.gmIncludeCoAuthoredBy {
		cfg.GitMaster = &config.GitMasterConfig{}
		if w.gmCommitFooter {
			cfg.GitMaster.CommitFooter = &w.gmCommitFooter
		}
		if w.gmIncludeCoAuthoredBy {
			cfg.GitMaster.IncludeCoAuthoredBy = &w.gmIncludeCoAuthoredBy
		}
	}

	// Comment Checker
	if v := w.ccCustomPrompt.Value(); v != "" {
		cfg.CommentChecker = &config.CommentCheckerConfig{
			CustomPrompt: v,
		}
	}
}

func (w WizardOther) Update(msg tea.Msg) (WizardOther, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		w.SetSize(msg.Width, msg.Height)
		return w, nil

	case tea.KeyMsg:
		if w.inSubSection {
			switch msg.String() {
			case "esc":
				w.inSubSection = false
				return w, nil
			case "up", "k":
				if w.subCursor > 0 {
					w.subCursor--
				}
			case "down", "j":
				w.subCursor++
			case " ", "enter":
				w.toggleSubItem()
			case "tab":
				w.inSubSection = false
			}
			return w, nil
		}

		switch {
		case key.Matches(msg, w.keys.Up):
			if w.currentSection > 0 {
				w.currentSection--
			}
		case key.Matches(msg, w.keys.Down):
			if w.currentSection < sectionCommentChecker {
				w.currentSection++
			}
		case key.Matches(msg, w.keys.Toggle):
			w.toggleSection()
		case key.Matches(msg, w.keys.Expand):
			w.sectionExpanded[w.currentSection] = !w.sectionExpanded[w.currentSection]
			if w.sectionExpanded[w.currentSection] {
				w.inSubSection = true
				w.subCursor = 0
			}
		case key.Matches(msg, w.keys.Next):
			return w, func() tea.Msg { return WizardNextMsg{} }
		case key.Matches(msg, w.keys.Back):
			return w, func() tea.Msg { return WizardBackMsg{} }
		}
	}

	// Update viewport
	w.viewport.SetContent(w.renderContent())
	w.viewport, cmd = w.viewport.Update(msg)

	return w, cmd
}

func (w *WizardOther) toggleSection() {
	switch w.currentSection {
	case sectionAutoUpdate:
		w.autoUpdate = !w.autoUpdate
	}
}

func (w *WizardOther) toggleSubItem() {
	switch w.currentSection {
	case sectionDisabledAgents:
		if w.subCursor < len(disableableAgents) {
			agent := disableableAgents[w.subCursor]
			w.disabledAgents[agent] = !w.disabledAgents[agent]
		}
	case sectionDisabledSkills:
		if w.subCursor < len(disableableSkills) {
			skill := disableableSkills[w.subCursor]
			w.disabledSkills[skill] = !w.disabledSkills[skill]
		}
	case sectionDisabledCommands:
		if w.subCursor < len(disableableCommands) {
			cmd := disableableCommands[w.subCursor]
			w.disabledCommands[cmd] = !w.disabledCommands[cmd]
		}
	case sectionExperimental:
		switch w.subCursor {
		case 0:
			w.expAggressiveTrunc = !w.expAggressiveTrunc
		case 1:
			w.expAutoResume = !w.expAutoResume
		case 2:
			w.expPreemptiveCompact = !w.expPreemptiveCompact
		case 3:
			w.expTruncateAllOutputs = !w.expTruncateAllOutputs
		case 4:
			w.expDcpForCompaction = !w.expDcpForCompaction
		}
	case sectionClaudeCode:
		switch w.subCursor {
		case 0:
			w.ccMcp = !w.ccMcp
		case 1:
			w.ccCommands = !w.ccCommands
		case 2:
			w.ccSkills = !w.ccSkills
		case 3:
			w.ccAgents = !w.ccAgents
		case 4:
			w.ccHooks = !w.ccHooks
		case 5:
			w.ccPlugins = !w.ccPlugins
		}
	case sectionSisyphusAgent:
		switch w.subCursor {
		case 0:
			w.saDisabled = !w.saDisabled
		case 1:
			w.saDefaultBuilderEnabled = !w.saDefaultBuilderEnabled
		case 2:
			w.saPlannerEnabled = !w.saPlannerEnabled
		case 3:
			w.saReplacePlan = !w.saReplacePlan
		}
	case sectionRalphLoop:
		if w.subCursor == 0 {
			w.rlEnabled = !w.rlEnabled
		}
	case sectionNotification:
		if w.subCursor == 0 {
			w.notifForceEnable = !w.notifForceEnable
		}
	case sectionGitMaster:
		switch w.subCursor {
		case 0:
			w.gmCommitFooter = !w.gmCommitFooter
		case 1:
			w.gmIncludeCoAuthoredBy = !w.gmIncludeCoAuthoredBy
		}
	}
}

func (w WizardOther) renderContent() string {
	var lines []string

	selectedStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#7D56F4"))
	enabledStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#A6E3A1"))
	disabledStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#F38BA8"))
	dimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#6C7086"))
	labelStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#CDD6F4"))

	for i, name := range otherSectionNames {
		section := otherSection(i)

		cursor := "  "
		if section == w.currentSection && !w.inSubSection {
			cursor = selectedStyle.Render("> ")
		}

		expandIcon := "▶"
		if w.sectionExpanded[section] {
			expandIcon = "▼"
		}

		// Simple sections without expansion
		if section == sectionAutoUpdate {
			checkbox := "[ ]"
			if w.autoUpdate {
				checkbox = enabledStyle.Render("[✓]")
			}
			line := fmt.Sprintf("%s%s %s", cursor, checkbox, labelStyle.Render(name))
			lines = append(lines, line)
			continue
		}

		line := fmt.Sprintf("%s%s %s", cursor, expandIcon, labelStyle.Render(name))
		lines = append(lines, line)

		// Render expanded content
		if w.sectionExpanded[section] {
			subLines := w.renderSubSection(section)
			lines = append(lines, subLines...)
		}
	}

	_ = dimStyle
	_ = disabledStyle
	return lipgloss.JoinVertical(lipgloss.Left, lines...)
}

func (w WizardOther) renderSubSection(section otherSection) []string {
	var lines []string
	indent := "      "

	selectedStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#7D56F4"))
	enabledStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#A6E3A1"))
	disabledStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#F38BA8"))
	dimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#6C7086"))

	renderCheckbox := func(idx int, label string, checked bool) string {
		cursor := "  "
		if w.inSubSection && w.currentSection == section && w.subCursor == idx {
			cursor = selectedStyle.Render("> ")
		}

		checkbox := "[ ]"
		if checked {
			checkbox = enabledStyle.Render("[✓]")
		}

		style := dimStyle
		if w.inSubSection && w.currentSection == section && w.subCursor == idx {
			style = lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#CDD6F4"))
		}

		return indent + cursor + checkbox + " " + style.Render(label)
	}

	_ = disabledStyle

	switch section {
	case sectionDisabledMcps:
		lines = append(lines, indent+"  "+w.disabledMcps.View())

	case sectionDisabledAgents:
		for i, agent := range disableableAgents {
			lines = append(lines, renderCheckbox(i, agent, w.disabledAgents[agent]))
		}

	case sectionDisabledSkills:
		for i, skill := range disableableSkills {
			lines = append(lines, renderCheckbox(i, skill, w.disabledSkills[skill]))
		}

	case sectionDisabledCommands:
		for i, cmd := range disableableCommands {
			lines = append(lines, renderCheckbox(i, cmd, w.disabledCommands[cmd]))
		}

	case sectionExperimental:
		lines = append(lines, renderCheckbox(0, "aggressive_truncation", w.expAggressiveTrunc))
		lines = append(lines, renderCheckbox(1, "auto_resume", w.expAutoResume))
		lines = append(lines, renderCheckbox(2, "preemptive_compaction", w.expPreemptiveCompact))
		lines = append(lines, renderCheckbox(3, "truncate_all_tool_outputs", w.expTruncateAllOutputs))
		lines = append(lines, renderCheckbox(4, "dcp_for_compaction", w.expDcpForCompaction))

	case sectionClaudeCode:
		lines = append(lines, renderCheckbox(0, "mcp", w.ccMcp))
		lines = append(lines, renderCheckbox(1, "commands", w.ccCommands))
		lines = append(lines, renderCheckbox(2, "skills", w.ccSkills))
		lines = append(lines, renderCheckbox(3, "agents", w.ccAgents))
		lines = append(lines, renderCheckbox(4, "hooks", w.ccHooks))
		lines = append(lines, renderCheckbox(5, "plugins", w.ccPlugins))

	case sectionSisyphusAgent:
		lines = append(lines, renderCheckbox(0, "disabled", w.saDisabled))
		lines = append(lines, renderCheckbox(1, "default_builder_enabled", w.saDefaultBuilderEnabled))
		lines = append(lines, renderCheckbox(2, "planner_enabled", w.saPlannerEnabled))
		lines = append(lines, renderCheckbox(3, "replace_plan", w.saReplacePlan))

	case sectionRalphLoop:
		lines = append(lines, renderCheckbox(0, "enabled", w.rlEnabled))
		lines = append(lines, indent+"  max_iterations: "+w.rlDefaultMaxIterations.View())
		lines = append(lines, indent+"  state_dir: "+w.rlStateDir.View())

	case sectionBackgroundTask:
		lines = append(lines, indent+"  default_concurrency: "+w.btDefaultConcurrency.View())

	case sectionNotification:
		lines = append(lines, renderCheckbox(0, "force_enable", w.notifForceEnable))

	case sectionGitMaster:
		lines = append(lines, renderCheckbox(0, "commit_footer", w.gmCommitFooter))
		lines = append(lines, renderCheckbox(1, "include_co_authored_by", w.gmIncludeCoAuthoredBy))

	case sectionCommentChecker:
		lines = append(lines, indent+"  custom_prompt: "+w.ccCustomPrompt.View())
	}

	lines = append(lines, "")
	return lines
}

func (w WizardOther) View() string {
	titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#CDD6F4"))
	helpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#6C7086"))

	title := titleStyle.Render("Other Settings")
	desc := helpStyle.Render("Enter to expand • Space to toggle • Tab next • Shift+Tab back")

	if w.inSubSection {
		desc = helpStyle.Render("Space/Enter to toggle • Esc to close section")
	}

	content := w.viewport.View()

	return lipgloss.JoinVertical(lipgloss.Left,
		title,
		desc,
		"",
		content,
	)
}
</file>
<file path="internal/tui/views/wizard_review.go">
package views

import (
	"encoding/json"
	"fmt"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/diogenes/omo-profiler/internal/config"
	"github.com/diogenes/omo-profiler/internal/schema"
)

type wizardReviewKeyMap struct {
	Up       key.Binding
	Down     key.Binding
	Save     key.Binding
	Back     key.Binding
	PageUp   key.Binding
	PageDown key.Binding
}

func newWizardReviewKeyMap() wizardReviewKeyMap {
	return wizardReviewKeyMap{
		Up: key.NewBinding(
			key.WithKeys("up", "k"),
			key.WithHelp("↑/k", "scroll up"),
		),
		Down: key.NewBinding(
			key.WithKeys("down", "j"),
			key.WithHelp("↓/j", "scroll down"),
		),
		Save: key.NewBinding(
			key.WithKeys("enter", "ctrl+s"),
			key.WithHelp("enter/ctrl+s", "save"),
		),
		Back: key.NewBinding(
			key.WithKeys("shift+tab", "esc"),
			key.WithHelp("shift+tab/esc", "back"),
		),
		PageUp: key.NewBinding(
			key.WithKeys("pgup"),
			key.WithHelp("pgup", "page up"),
		),
		PageDown: key.NewBinding(
			key.WithKeys("pgdown"),
			key.WithHelp("pgdown", "page down"),
		),
	}
}

// WizardReview is step 5: Review and save
type WizardReview struct {
	profileName    string
	config         *config.Config
	jsonPreview    string
	validationErrs []schema.ValidationError
	isValid        bool
	viewport       viewport.Model
	ready          bool
	width          int
	height         int
	keys           wizardReviewKeyMap
}

func NewWizardReview() WizardReview {
	return WizardReview{
		keys: newWizardReviewKeyMap(),
	}
}

func (w WizardReview) Init() tea.Cmd {
	return nil
}

func (w *WizardReview) SetSize(width, height int) {
	w.width = width
	w.height = height
	if !w.ready {
		w.viewport = viewport.New(width, height-8)
		w.ready = true
	} else {
		w.viewport.Width = width
		w.viewport.Height = height - 8
	}
}

func (w *WizardReview) SetConfig(name string, cfg *config.Config) {
	w.profileName = name
	w.config = cfg
	w.validateAndPreview()
}

func (w *WizardReview) validateAndPreview() {
	if w.config == nil {
		w.jsonPreview = "{}"
		w.isValid = true
		return
	}

	// Generate JSON preview
	jsonData, err := json.MarshalIndent(w.config, "", "  ")
	if err != nil {
		w.jsonPreview = fmt.Sprintf("Error generating preview: %v", err)
		w.isValid = false
		return
	}
	w.jsonPreview = string(jsonData)

	// Validate against schema
	validator, err := schema.NewValidator()
	if err != nil {
		w.validationErrs = nil
		w.isValid = true // Can't validate, assume valid
		return
	}

	errs, err := validator.Validate(w.config)
	if err != nil {
		w.validationErrs = nil
		w.isValid = true // Validation error, assume valid
		return
	}

	w.validationErrs = errs
	w.isValid = len(errs) == 0
}

func (w WizardReview) Update(msg tea.Msg) (WizardReview, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		w.SetSize(msg.Width, msg.Height)
		return w, nil

	case tea.KeyMsg:
		switch {
		case key.Matches(msg, w.keys.Save):
			if w.isValid {
				return w, func() tea.Msg { return WizardNextMsg{} }
			}
			return w, nil
		case key.Matches(msg, w.keys.Back):
			return w, func() tea.Msg { return WizardBackMsg{} }
		}
	}

	// Update viewport
	w.viewport, cmd = w.viewport.Update(msg)

	return w, cmd
}

func (w WizardReview) View() string {
	titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#CDD6F4"))
	helpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#6C7086"))
	errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#F38BA8"))
	successStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#A6E3A1"))
	codeStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#89B4FA"))

	title := titleStyle.Render("Review & Save")

	// Profile name
	nameLabel := helpStyle.Render("Profile Name: ") + titleStyle.Render(w.profileName)

	// Validation status
	var validationStatus string
	if w.isValid {
		validationStatus = successStyle.Render("✓ Configuration is valid")
	} else {
		validationStatus = errorStyle.Render("✗ Validation errors found:")
		for _, e := range w.validationErrs {
			validationStatus += "\n  " + errorStyle.Render(fmt.Sprintf("• %s: %s", e.Path, e.Message))
		}
	}

	// JSON preview in viewport
	w.viewport.SetContent(codeStyle.Render(w.jsonPreview))
	preview := w.viewport.View()

	// Help text
	var help string
	if w.isValid {
		help = helpStyle.Render("Enter to save • Shift+Tab to go back • ↑/↓ to scroll")
	} else {
		help = helpStyle.Render("Fix errors before saving • Shift+Tab to go back")
	}

	return lipgloss.JoinVertical(lipgloss.Left,
		title,
		nameLabel,
		"",
		validationStatus,
		"",
		titleStyle.Render("JSON Preview:"),
		preview,
		"",
		help,
	)
}

// IsValid returns true if the config passes validation
func (w WizardReview) IsValid() bool {
	return w.isValid
}

// GetErrors returns validation errors
func (w WizardReview) GetErrors() []schema.ValidationError {
	return w.validationErrs
}
</file>
<file path="internal/tui/app.go">
package tui

import (
	"time"

	"github.com/charmbracelet/bubbles/help"
	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/spinner"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/diogenes/omo-profiler/internal/profile"
	"github.com/diogenes/omo-profiler/internal/tui/views"
)

type appState int

const (
	stateDashboard appState = iota
	stateList
	stateWizard
	stateEditor
	stateDiff
	stateImport
	stateExport
)

// Toast message types
type toastType int

const (
	toastSuccess toastType = iota
	toastError
	toastInfo
)

type toastMsg struct {
	text     string
	typ      toastType
	duration time.Duration
}

type clearToastMsg struct{}

// Operation messages
type switchProfileDoneMsg struct {
	name string
	err  error
}

type deleteProfileDoneMsg struct {
	name string
	err  error
}

type App struct {
	state     appState
	prevState appState
	width     int
	height    int
	ready     bool

	// Help
	help     help.Model
	showHelp bool

	// Loading state
	spinner spinner.Model
	loading bool

	// Toast notification
	toast       string
	toastType   toastType
	toastActive bool

	// Views
	dashboard views.Dashboard
	list      views.List
	wizard    views.Wizard
	editor    views.Editor
	diff      views.Diff

	// Context for editor
	editProfileName string
}

func NewApp() App {
	h := help.New()
	h.Styles.ShortKey = HelpStyle
	h.Styles.ShortDesc = HelpStyle
	h.Styles.FullKey = HelpStyle
	h.Styles.FullDesc = HelpStyle

	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = lipgloss.NewStyle().Foreground(Purple)

	return App{
		state:     stateDashboard,
		help:      h,
		spinner:   s,
		dashboard: views.NewDashboard(),
		list:      views.NewList(),
		diff:      views.NewDiff(),
	}
}

func (a App) Init() tea.Cmd {
	return tea.Batch(
		a.dashboard.Init(),
		a.spinner.Tick,
	)
}

func (a App) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		// Global keys (unless in text input mode)
		switch {
		case key.Matches(msg, Keys.Quit):
			return a, tea.Quit
		case key.Matches(msg, Keys.Help):
			a.showHelp = !a.showHelp
			return a, nil
		case key.Matches(msg, Keys.Back):
			// Don't intercept Esc if a view handles it internally
			if a.state == stateWizard || a.state == stateEditor || a.state == stateDiff {
				// Let the view handle it
				break
			}
			if a.state != stateDashboard {
				return a.navigateTo(stateDashboard)
			}
			return a, nil
		}

	case tea.WindowSizeMsg:
		a.width = msg.Width
		a.height = msg.Height
		a.help.Width = msg.Width
		a.ready = true

		// Propagate to all views
		a.dashboard.SetSize(msg.Width, msg.Height-3)
		a.list.SetSize(msg.Width, msg.Height-3)
		a.wizard.SetSize(msg.Width, msg.Height-3)
		a.editor.SetSize(msg.Width, msg.Height-3)

	case spinner.TickMsg:
		if a.loading {
			a.spinner, cmd = a.spinner.Update(msg)
			cmds = append(cmds, cmd)
		}

	case clearToastMsg:
		a.toast = ""
		a.toastActive = false
		return a, nil

	case toastMsg:
		a.toast = msg.text
		a.toastType = msg.typ
		a.toastActive = true
		return a, tea.Tick(msg.duration, func(time.Time) tea.Msg {
			return clearToastMsg{}
		})

	// Navigation messages from Dashboard
	case views.NavToListMsg:
		a.list = views.NewList()
		a.list.SetSize(a.width, a.height-3)
		return a.navigateTo(stateList)

	case views.NavToWizardMsg:
		a.wizard = views.NewWizard()
		a.wizard.SetSize(a.width, a.height-3)
		return a.navigateTo(stateWizard)

	case views.NavToEditorMsg:
		// Edit current active profile
		active, err := profile.GetActive()
		if err != nil || active == nil || !active.Exists || active.IsOrphan {
			return a, a.showToast("No active profile to edit", toastError, 3*time.Second)
		}
		a.editProfileName = active.ProfileName
		a.editor = views.NewEditor(active.ProfileName)
		a.editor.SetSize(a.width, a.height-3)
		return a.navigateTo(stateEditor)

	case views.NavToDiffMsg:
		a.diff = views.NewDiff()
		return a.navigateTo(stateDiff)

	case views.NavToImportMsg:
		return a, a.showToast("Import not yet implemented", toastInfo, 2*time.Second)

	case views.NavToExportMsg:
		return a, a.showToast("Export not yet implemented", toastInfo, 2*time.Second)

	// Navigation from List
	case views.NavigateToDashboardMsg:
		return a.navigateTo(stateDashboard)

	case views.NavigateToWizardMsg:
		a.wizard = views.NewWizard()
		a.wizard.SetSize(a.width, a.height-3)
		return a.navigateTo(stateWizard)

	case views.SwitchProfileMsg:
		a.loading = true
		return a, tea.Batch(
			a.spinner.Tick,
			a.doSwitchProfile(msg.Name),
		)

	case switchProfileDoneMsg:
		a.loading = false
		if msg.err != nil {
			return a, a.showToast("Switch failed: "+msg.err.Error(), toastError, 3*time.Second)
		}
		cmds = append(cmds, a.showToast("Switched to: "+msg.name, toastSuccess, 3*time.Second))
		a.dashboard = views.NewDashboard()
		a.dashboard.SetSize(a.width, a.height-3)
		cmds = append(cmds, a.dashboard.Init())
		a.state = stateDashboard
		return a, tea.Batch(cmds...)

	case views.EditProfileMsg:
		a.editProfileName = msg.Name
		a.editor = views.NewEditor(msg.Name)
		a.editor.SetSize(a.width, a.height-3)
		return a.navigateTo(stateEditor)

	case views.DeleteProfileMsg:
		a.loading = true
		return a, tea.Batch(
			a.spinner.Tick,
			a.doDeleteProfile(msg.Name),
		)

	case deleteProfileDoneMsg:
		a.loading = false
		if msg.err != nil {
			return a, a.showToast("Delete failed: "+msg.err.Error(), toastError, 3*time.Second)
		}
		cmds = append(cmds, a.showToast("Deleted: "+msg.name, toastSuccess, 3*time.Second))
		// Refresh list
		a.list = views.NewList()
		a.list.SetSize(a.width, a.height-3)
		cmds = append(cmds, a.list.Init())
		return a, tea.Batch(cmds...)

	// Wizard messages
	case views.WizardSaveMsg:
		cmds = append(cmds, a.showToast("Profile saved!", toastSuccess, 3*time.Second))
		a.dashboard = views.NewDashboard()
		a.dashboard.SetSize(a.width, a.height-3)
		cmds = append(cmds, a.dashboard.Init())
		a.state = stateDashboard
		return a, tea.Batch(cmds...)

	case views.WizardCancelMsg:
		return a.navigateTo(stateDashboard)

	// Editor messages
	case views.EditorSaveSuccessMsg:
		cmds = append(cmds, a.showToast("Profile saved!", toastSuccess, 3*time.Second))
		a.dashboard = views.NewDashboard()
		a.dashboard.SetSize(a.width, a.height-3)
		cmds = append(cmds, a.dashboard.Init())
		a.state = stateDashboard
		return a, tea.Batch(cmds...)

	case views.EditorCancelMsg:
		return a.navigateTo(stateDashboard)
	}

	// Delegate update to current view
	switch a.state {
	case stateDashboard:
		a.dashboard, cmd = a.dashboard.Update(msg)
		cmds = append(cmds, cmd)

	case stateList:
		a.list, cmd = a.list.Update(msg)
		cmds = append(cmds, cmd)

	case stateWizard:
		a.wizard, cmd = a.wizard.Update(msg)
		cmds = append(cmds, cmd)

	case stateEditor:
		a.editor, cmd = a.editor.Update(msg)
		cmds = append(cmds, cmd)

	case stateDiff:
		a.diff, cmd = a.diff.Update(msg)
		cmds = append(cmds, cmd)
	}

	return a, tea.Batch(cmds...)
}

func (a App) navigateTo(state appState) (App, tea.Cmd) {
	a.prevState = a.state
	a.state = state

	var cmd tea.Cmd
	switch state {
	case stateDashboard:
		a.dashboard = views.NewDashboard()
		a.dashboard.SetSize(a.width, a.height-3)
		cmd = a.dashboard.Init()
	case stateList:
		cmd = a.list.Init()
	case stateWizard:
		cmd = a.wizard.Init()
	case stateEditor:
		cmd = a.editor.Init()
	case stateDiff:
		cmd = a.diff.Init()
	}

	return a, cmd
}

func (a App) doSwitchProfile(name string) tea.Cmd {
	return func() tea.Msg {
		err := profile.SetActive(name)
		return switchProfileDoneMsg{name: name, err: err}
	}
}

func (a App) doDeleteProfile(name string) tea.Cmd {
	return func() tea.Msg {
		err := profile.Delete(name)
		return deleteProfileDoneMsg{name: name, err: err}
	}
}

func (a App) showToast(text string, typ toastType, duration time.Duration) tea.Cmd {
	return func() tea.Msg {
		return toastMsg{text: text, typ: typ, duration: duration}
	}
}

func (a App) View() string {
	if !a.ready {
		return "Initializing..."
	}

	var content string

	// Loading overlay
	if a.loading {
		content = lipgloss.Place(
			a.width,
			a.height-3,
			lipgloss.Center,
			lipgloss.Center,
			a.spinner.View()+" Loading...",
		)
	} else {
		switch a.state {
		case stateDashboard:
			content = a.dashboard.View()
		case stateList:
			content = a.list.View()
		case stateWizard:
			content = a.wizard.View()
		case stateEditor:
			content = a.editor.View()
		case stateDiff:
			content = a.diff.View()
		case stateImport:
			content = a.placeholderView("Import Profile")
		case stateExport:
			content = a.placeholderView("Export Profile")
		default:
			content = "Unknown state"
		}
	}

	// Toast notification
	var toastView string
	if a.toastActive && a.toast != "" {
		var style lipgloss.Style
		switch a.toastType {
		case toastSuccess:
			style = SuccessStyle.Copy().Padding(0, 1)
		case toastError:
			style = ErrorStyle.Copy().Padding(0, 1)
		default:
			style = CyanAccentStyle.Copy().Padding(0, 1)
		}
		toastView = style.Render(a.toast)
	}

	// Help view
	var helpView string
	if a.showHelp {
		helpView = a.renderFullHelp()
	} else {
		helpView = a.renderShortHelp()
	}

	// Build final layout
	var parts []string
	parts = append(parts, content)

	if toastView != "" {
		parts = append(parts, toastView)
	}

	parts = append(parts, helpView)

	return lipgloss.JoinVertical(lipgloss.Left, parts...)
}

func (a App) renderShortHelp() string {
	var hints []string

	switch a.state {
	case stateDashboard:
		hints = []string{"↑↓ navigate", "enter select", "? help", "q quit"}
	case stateList:
		hints = []string{"enter switch", "e edit", "d delete", "n new", "/ search", "esc back"}
	case stateWizard:
		hints = []string{"tab/enter next", "shift+tab back", "ctrl+s save", "ctrl+c cancel"}
	case stateEditor:
		hints = []string{"tab switch focus", "ctrl+s save", "esc back"}
	case stateDiff:
		hints = []string{"tab switch pane", "enter select", "↑↓ scroll", "esc back"}
	default:
		hints = []string{"? help", "q quit"}
	}

	return HelpStyle.Render(lipgloss.JoinHorizontal(lipgloss.Top, joinWithSeparator(hints, " • ")...))
}

func (a App) renderFullHelp() string {
	var lines []string

	lines = append(lines, TitleStyle.Render("Keyboard Shortcuts"))
	lines = append(lines, "")

	// Global keys
	lines = append(lines, AccentStyle.Render("Global:"))
	lines = append(lines, HelpStyle.Render("  q/ctrl+c   Quit application"))
	lines = append(lines, HelpStyle.Render("  ?          Toggle help"))
	lines = append(lines, HelpStyle.Render("  esc        Back/Cancel"))
	lines = append(lines, "")

	// Context-specific keys
	switch a.state {
	case stateDashboard:
		lines = append(lines, AccentStyle.Render("Dashboard:"))
		lines = append(lines, HelpStyle.Render("  ↑/k        Move up"))
		lines = append(lines, HelpStyle.Render("  ↓/j        Move down"))
		lines = append(lines, HelpStyle.Render("  enter      Select menu item"))

	case stateList:
		lines = append(lines, AccentStyle.Render("Profile List:"))
		lines = append(lines, HelpStyle.Render("  ↑/k        Move up"))
		lines = append(lines, HelpStyle.Render("  ↓/j        Move down"))
		lines = append(lines, HelpStyle.Render("  enter      Switch to profile"))
		lines = append(lines, HelpStyle.Render("  e          Edit profile"))
		lines = append(lines, HelpStyle.Render("  d          Delete profile"))
		lines = append(lines, HelpStyle.Render("  n          New profile"))
		lines = append(lines, HelpStyle.Render("  /          Search profiles"))

	case stateWizard:
		lines = append(lines, AccentStyle.Render("Profile Wizard:"))
		lines = append(lines, HelpStyle.Render("  tab/enter  Next step"))
		lines = append(lines, HelpStyle.Render("  shift+tab  Previous step"))
		lines = append(lines, HelpStyle.Render("  ctrl+s     Save profile"))
		lines = append(lines, HelpStyle.Render("  ctrl+c     Cancel"))

	case stateEditor:
		lines = append(lines, AccentStyle.Render("Profile Editor:"))
		lines = append(lines, HelpStyle.Render("  ↑/k        Move up"))
		lines = append(lines, HelpStyle.Render("  ↓/j        Move down"))
		lines = append(lines, HelpStyle.Render("  tab        Switch focus"))
		lines = append(lines, HelpStyle.Render("  space      Toggle option"))
		lines = append(lines, HelpStyle.Render("  ctrl+s     Save changes"))

	case stateDiff:
		lines = append(lines, AccentStyle.Render("Profile Diff:"))
		lines = append(lines, HelpStyle.Render("  ↑/k        Scroll up"))
		lines = append(lines, HelpStyle.Render("  ↓/j        Scroll down"))
		lines = append(lines, HelpStyle.Render("  tab        Switch pane"))
		lines = append(lines, HelpStyle.Render("  enter      Select profile"))
		lines = append(lines, HelpStyle.Render("  pgup/pgdn  Page scroll"))
	}

	lines = append(lines, "")
	lines = append(lines, HelpStyle.Render("Press ? to close help"))

	return lipgloss.JoinVertical(lipgloss.Left, lines...)
}

func (a App) placeholderView(title string) string {
	return TitleStyle.Render(title) + "\n\n" +
		SubtitleStyle.Render("(Coming soon)")
}

func joinWithSeparator(items []string, sep string) []string {
	if len(items) == 0 {
		return nil
	}
	result := make([]string, 0, len(items)*2-1)
	for i, item := range items {
		if i > 0 {
			result = append(result, sep)
		}
		result = append(result, item)
	}
	return result
}
</file>
<file path="internal/tui/keys.go">
package tui

import "github.com/charmbracelet/bubbles/key"

type keyMap struct {
	Quit  key.Binding
	Help  key.Binding
	Back  key.Binding
	Up    key.Binding
	Down  key.Binding
	Left  key.Binding
	Right key.Binding
	Enter key.Binding
}

func (k keyMap) ShortHelp() []key.Binding {
	return []key.Binding{k.Help, k.Quit}
}

func (k keyMap) FullHelp() [][]key.Binding {
	return [][]key.Binding{
		{k.Up, k.Down, k.Left, k.Right},
		{k.Enter, k.Back},
		{k.Help, k.Quit},
	}
}

var Keys = keyMap{
	Quit: key.NewBinding(
		key.WithKeys("q", "ctrl+c"),
		key.WithHelp("q", "quit"),
	),
	Help: key.NewBinding(
		key.WithKeys("?"),
		key.WithHelp("?", "help"),
	),
	Back: key.NewBinding(
		key.WithKeys("esc"),
		key.WithHelp("esc", "back"),
	),
	Up: key.NewBinding(
		key.WithKeys("up", "k"),
		key.WithHelp("↑/k", "up"),
	),
	Down: key.NewBinding(
		key.WithKeys("down", "j"),
		key.WithHelp("↓/j", "down"),
	),
	Left: key.NewBinding(
		key.WithKeys("left", "h"),
		key.WithHelp("←/h", "left"),
	),
	Right: key.NewBinding(
		key.WithKeys("right", "l"),
		key.WithHelp("→/l", "right"),
	),
	Enter: key.NewBinding(
		key.WithKeys("enter"),
		key.WithHelp("enter", "select"),
	),
}
</file>
<file path="internal/tui/styles.go">
package tui

import "github.com/charmbracelet/lipgloss"

var (
	Purple  = lipgloss.Color("#7D56F4")
	Magenta = lipgloss.Color("#FF6AC1")
	Cyan    = lipgloss.Color("#78DCE8")
	Green   = lipgloss.Color("#A6E3A1")
	Red     = lipgloss.Color("#F38BA8")
	Yellow  = lipgloss.Color("#F9E2AF")
	Gray    = lipgloss.Color("#6C7086")
	White   = lipgloss.Color("#CDD6F4")
)

var (
	TitleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(Purple)

	SubtitleStyle = lipgloss.NewStyle().
			Foreground(Gray)

	ActiveStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(White).
			Background(Purple)

	InactiveStyle = lipgloss.NewStyle().
			Foreground(White)

	ErrorStyle = lipgloss.NewStyle().
			Foreground(Red)

	SuccessStyle = lipgloss.NewStyle().
			Foreground(Green)

	WarningStyle = lipgloss.NewStyle().
			Foreground(Yellow)

	BorderStyle = lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(Purple).
			Padding(1, 2)

	HelpStyle = lipgloss.NewStyle().
			Foreground(Gray)

	AccentStyle = lipgloss.NewStyle().
			Foreground(Magenta)

	CyanAccentStyle = lipgloss.NewStyle().
			Foreground(Cyan)
)
</file>
<file path="internal/tui/tui.go">
package tui

import tea "github.com/charmbracelet/bubbletea"

func Run() error {
	app := NewApp()
	p := tea.NewProgram(app, tea.WithAltScreen())
	_, err := p.Run()
	return err
}
</file>
<file path="go.mod">
module github.com/diogenes/omo-profiler

go 1.25.6

require (
	github.com/charmbracelet/bubbles v0.21.0
	github.com/charmbracelet/bubbletea v1.3.10
	github.com/charmbracelet/lipgloss v1.1.0
	github.com/sergi/go-diff v1.4.0
	github.com/spf13/cobra v1.10.2
	github.com/stretchr/testify v1.11.1
	github.com/xeipuuv/gojsonschema v1.2.0
)

require (
	github.com/atotto/clipboard v0.1.4 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/x/ansi v0.10.1 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.16.0 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/sahilm/fuzzy v0.1.1 // indirect
	github.com/spf13/pflag v1.0.9 // indirect
	github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f // indirect
	github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	golang.org/x/sys v0.36.0 // indirect
	golang.org/x/text v0.3.8 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
</file>
<file path="go.sum">
github.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=
github.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/aymanbagabas/go-udiff v0.2.0 h1:TK0fH4MteXUDspT88n8CKzvK0X9O2xu9yQjWpi6yML8=
github.com/aymanbagabas/go-udiff v0.2.0/go.mod h1:RE4Ex0qsGkTAJoQdQQCA0uG+nAzJO/pI/QwceO5fgrA=
github.com/charmbracelet/bubbles v0.21.0 h1:9TdC97SdRVg/1aaXNVWfFH3nnLAwOXr8Fn6u6mfQdFs=
github.com/charmbracelet/bubbles v0.21.0/go.mod h1:HF+v6QUR4HkEpz62dx7ym2xc71/KBHg+zKwJtMw+qtg=
github.com/charmbracelet/bubbletea v1.3.10 h1:otUDHWMMzQSB0Pkc87rm691KZ3SWa4KUlvF9nRvCICw=
github.com/charmbracelet/bubbletea v1.3.10/go.mod h1:ORQfo0fk8U+po9VaNvnV95UPWA1BitP1E0N6xJPlHr4=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc h1:4pZI35227imm7yK2bGPcfpFEmuY1gc2YSTShr4iJBfs=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc/go.mod h1:X4/0JoqgTIPSFcRA/P6INZzIuyqdFY5rm8tb41s9okk=
github.com/charmbracelet/lipgloss v1.1.0 h1:vYXsiLHVkK7fp74RkV7b2kq9+zDLoEU4MZoFqR/noCY=
github.com/charmbracelet/lipgloss v1.1.0/go.mod h1:/6Q8FR2o+kj8rz4Dq0zQc3vYf7X+B0binUUBwA0aL30=
github.com/charmbracelet/x/ansi v0.10.1 h1:rL3Koar5XvX0pHGfovN03f5cxLbCF2YvLeyz7D2jVDQ=
github.com/charmbracelet/x/ansi v0.10.1/go.mod h1:3RQDQ6lDnROptfpWuUVIUG64bD2g2BgntdxH0Ya5TeE=
github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd h1:vy0GVL4jeHEwG5YOXDmi86oYw2yuYUGqz6a8sLwg0X8=
github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd/go.mod h1:xe0nKWGd3eJgtqZRaN9RjMtK7xUYchjzPr7q6kcvCCs=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91 h1:payRxjMjKgx2PaCWLZ4p3ro9y97+TVLZNaRZgJwSVDQ=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91/go.mod h1:wDlXFlCrmJ8J+swcL/MnGUuYnqgQdW9rhSD61oNMb6U=
github.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=
github.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=
github.com/cpuguy83/go-md2man/v2 v2.0.6/go.mod h1:oOW0eioCTA6cOiMLiUPZOpcVxMig6NIQQ7OS05n1F4g=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=
github.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=
github.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=
github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=
github.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=
github.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=
github.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=
github.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=
github.com/muesli/termenv v0.16.0 h1:S5AlUN9dENB57rsbnkPyfdGuWIlkmzJjbFf0Tf5FWUc=
github.com/muesli/termenv v0.16.0/go.mod h1:ZRfOIKPFDYQoDFF4Olj7/QJbW60Ol/kL1pU3VfY/Cnk=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/sahilm/fuzzy v0.1.1 h1:ceu5RHF8DGgoi+/dR5PsECjCDH1BE3Fnmpo7aVXOdRA=
github.com/sahilm/fuzzy v0.1.1/go.mod h1:VFvziUEIMCrT6A6tw2RFIXPXXmzXbOsSHF0DOI8ZK9Y=
github.com/sergi/go-diff v1.4.0 h1:n/SP9D5ad1fORl+llWyN+D6qoUETXNZARKjyY2/KVCw=
github.com/sergi/go-diff v1.4.0/go.mod h1:A0bzQcvG0E7Rwjx0REVgAGH58e96+X0MeOfepqsbeW4=
github.com/spf13/cobra v1.10.2 h1:DMTTonx5m65Ic0GOoRY2c16WCbHxOOw6xxezuLaBpcU=
github.com/spf13/cobra v1.10.2/go.mod h1:7C1pvHqHw5A4vrJfjNwvOdzYu0Gml16OCs2GRiTUUS4=
github.com/spf13/pflag v1.0.9 h1:9exaQaMOCwffKiiiYk6/BndUBv+iRViNW+4lEMi0PvY=
github.com/spf13/pflag v1.0.9/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.11.1 h1:7s2iGBzp5EwR7/aIZr8ao5+dra3wiQyKjjFuvgVKu7U=
github.com/stretchr/testify v1.11.1/go.mod h1:wZwfW3scLgRK+23gO65QZefKpKQRnfz6sD981Nm4B6U=
github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f h1:J9EGpcZtP0E/raorCMxlFGSTBrsSlaDGf3jU/qvAE2c=
github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f/go.mod h1:N2zxlSyiKSe5eX1tZViRH5QA0qijqEDrYZiPEAiq3wU=
github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 h1:EzJWgHovont7NscjpAxXsDA8S8BMYve8Y5+7cuRE7R0=
github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415/go.mod h1:GwrjFmJcFw6At/Gs6z4yjiIwzuJ1/+UwLxMQDVQXShQ=
github.com/xeipuuv/gojsonschema v1.2.0 h1:LhYJRs+L4fBtjZUfuSZIKGeVu0QRy8e5Xi7D17UxZ74=
github.com/xeipuuv/gojsonschema v1.2.0/go.mod h1:anYRn/JVcOK2ZgGU+IjEV4nwlhoK5sQluxsYJ78Id3Y=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=
go.yaml.in/yaml/v3 v3.0.4/go.mod h1:DhzuOOF2ATzADvBadXxruRBLzYTpT36CKvDb3+aBEFg=
golang.org/x/exp v0.0.0-20220909182711-5c715a9e8561 h1:MDc5xs78ZrZr3HMQugiXOAkSZtfTpbJLDr/lwfgO53E=
golang.org/x/exp v0.0.0-20220909182711-5c715a9e8561/go.mod h1:cyybsKvd6eL0RnXn6p/Grxp8F5bW7iYuBgsNCOHpMYE=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.36.0 h1:KVRy2GtZBrk1cBYA7MKu5bEZFxQk4NIDV6RLVcC8o0k=
golang.org/x/sys v0.36.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/text v0.3.8 h1:nAL+RVCQ9uMn3vJZbV+MRnydTJFPf8qqY42YiA6MrqY=
golang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=
gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
</file>
<file path="Makefile">
# omo-profiler Makefile

BINARY_NAME := omo-profiler
INSTALL_PATH := $(HOME)/.local/bin
GO := go
GOFLAGS := -v

.PHONY: all build install uninstall test lint clean help

all: build

## Build the binary
build:
	$(GO) build $(GOFLAGS) -o $(BINARY_NAME) ./cmd/omo-profiler

## Install binary to ~/.local/bin
install: build
	@mkdir -p $(INSTALL_PATH)
	@cp $(BINARY_NAME) $(INSTALL_PATH)/$(BINARY_NAME)
	@echo "Installed $(BINARY_NAME) to $(INSTALL_PATH)"

## Remove installed binary
uninstall:
	@rm -f $(INSTALL_PATH)/$(BINARY_NAME)
	@echo "Uninstalled $(BINARY_NAME) from $(INSTALL_PATH)"

## Run all tests
test:
	$(GO) test $(GOFLAGS) ./...

## Run linter (requires golangci-lint)
lint:
	@command -v golangci-lint >/dev/null 2>&1 || { echo "golangci-lint not found. Install: go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest"; exit 1; }
	golangci-lint run ./...

## Remove build artifacts
clean:
	@rm -f $(BINARY_NAME)
	$(GO) clean

## Show help
help:
	@echo "Available targets:"
	@echo "  build     - Build the binary"
	@echo "  install   - Install binary to $(INSTALL_PATH)"
	@echo "  uninstall - Remove installed binary"
	@echo "  test      - Run all tests"
	@echo "  lint      - Run golangci-lint"
	@echo "  clean     - Remove build artifacts"
	@echo "  help      - Show this help"
</file>
<file path="README.md">
# omo-profiler

TUI profile manager for oh-my-opencode

## Installation

```bash
go install github.com/diogenes/omo-profiler/cmd/omo-profiler@latest
```

## Quick Start

```bash
# Launch TUI
omo-profiler

# List profiles
omo-profiler list

# Show current profile
omo-profiler current

# Switch profile
omo-profiler switch <profile-name>

# Import profile
omo-profiler import <file.json>

# Export profile
omo-profiler export <profile-name> <output.json>
```

## CLI Reference

| Command | Description |
|---------|-------------|
| `omo-profiler` | Launch TUI |
| `omo-profiler list` | List all profiles |
| `omo-profiler current` | Show active profile |
| `omo-profiler switch <name>` | Activate profile |
| `omo-profiler import <file>` | Import profile from JSON |
| `omo-profiler export <name> <path>` | Export profile to file |

## Features

- Dashboard with active profile overview
- Create profiles with step-by-step wizard
- Edit existing profiles
- Compare profiles side-by-side
- Import/export profiles
- Schema validation against oh-my-opencode
- Automatic backups on profile switch

## Profile Location

Profiles are stored in `~/.config/opencode/profiles/`

Active config: `~/.config/opencode/oh-my-opencode.json`
</file>
<file path="schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://raw.githubusercontent.com/code-yeongyu/oh-my-opencode/master/assets/oh-my-opencode.schema.json",
  "title": "Oh My OpenCode Configuration",
  "description": "Configuration schema for oh-my-opencode plugin",
  "type": "object",
  "properties": {
    "$schema": {
      "type": "string"
    },
    "disabled_mcps": {
      "type": "array",
      "items": {
        "type": "string",
        "minLength": 1
      }
    },
    "disabled_agents": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "Sisyphus",
          "oracle",
          "librarian",
          "explore",
          "frontend-ui-ux-engineer",
          "document-writer",
          "multimodal-looker",
          "Metis (Plan Consultant)",
          "Momus (Plan Reviewer)",
          "orchestrator-sisyphus"
        ]
      }
    },
    "disabled_skills": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "playwright",
          "frontend-ui-ux",
          "git-master"
        ]
      }
    },
    "disabled_hooks": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "todo-continuation-enforcer",
          "context-window-monitor",
          "session-recovery",
          "session-notification",
          "comment-checker",
          "grep-output-truncator",
          "tool-output-truncator",
          "directory-agents-injector",
          "directory-readme-injector",
          "empty-task-response-detector",
          "think-mode",
          "anthropic-context-window-limit-recovery",
          "rules-injector",
          "background-notification",
          "auto-update-checker",
          "startup-toast",
          "keyword-detector",
          "agent-usage-reminder",
          "non-interactive-env",
          "interactive-bash-session",
          "empty-message-sanitizer",
          "thinking-block-validator",
          "ralph-loop",
          "preemptive-compaction",
          "compaction-context-injector",
          "claude-code-hooks",
          "auto-slash-command",
          "edit-error-recovery",
          "prometheus-md-only",
          "start-work",
          "sisyphus-orchestrator"
        ]
      }
    },
    "disabled_commands": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "init-deep",
          "start-work"
        ]
      }
    },
    "agents": {
      "type": "object",
      "properties": {
        "build": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "plan": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "Sisyphus": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "Sisyphus-Junior": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "OpenCode-Builder": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "Prometheus (Planner)": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "Metis (Plan Consultant)": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "Momus (Plan Reviewer)": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "oracle": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "librarian": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "explore": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "frontend-ui-ux-engineer": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "document-writer": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "multimodal-looker": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        },
        "orchestrator-sisyphus": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string"
            },
            "variant": {
              "type": "string"
            },
            "category": {
              "type": "string"
            },
            "skills": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1
            },
            "prompt": {
              "type": "string"
            },
            "prompt_append": {
              "type": "string"
            },
            "tools": {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "type": "boolean"
              }
            },
            "disable": {
              "type": "boolean"
            },
            "description": {
              "type": "string"
            },
            "mode": {
              "type": "string",
              "enum": [
                "subagent",
                "primary",
                "all"
              ]
            },
            "color": {
              "type": "string",
              "pattern": "^#[0-9A-Fa-f]{6}$"
            },
            "permission": {
              "type": "object",
              "properties": {
                "edit": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "bash": {
                  "anyOf": [
                    {
                      "type": "string",
                      "enum": [
                        "ask",
                        "allow",
                        "deny"
                      ]
                    },
                    {
                      "type": "object",
                      "propertyNames": {
                        "type": "string"
                      },
                      "additionalProperties": {
                        "type": "string",
                        "enum": [
                          "ask",
                          "allow",
                          "deny"
                        ]
                      }
                    }
                  ]
                },
                "webfetch": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "doom_loop": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                },
                "external_directory": {
                  "type": "string",
                  "enum": [
                    "ask",
                    "allow",
                    "deny"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "categories": {
      "type": "object",
      "propertyNames": {
        "type": "string"
      },
      "additionalProperties": {
        "type": "object",
        "properties": {
          "model": {
            "type": "string"
          },
          "variant": {
            "type": "string"
          },
          "temperature": {
            "type": "number",
            "minimum": 0,
            "maximum": 2
          },
          "top_p": {
            "type": "number",
            "minimum": 0,
            "maximum": 1
          },
          "maxTokens": {
            "type": "number"
          },
          "thinking": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "enabled",
                  "disabled"
                ]
              },
              "budgetTokens": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          },
          "reasoningEffort": {
            "type": "string",
            "enum": [
              "low",
              "medium",
              "high"
            ]
          },
          "textVerbosity": {
            "type": "string",
            "enum": [
              "low",
              "medium",
              "high"
            ]
          },
          "tools": {
            "type": "object",
            "propertyNames": {
              "type": "string"
            },
            "additionalProperties": {
              "type": "boolean"
            }
          },
          "prompt_append": {
            "type": "string"
          }
        },
        "required": [
          "model"
        ]
      }
    },
    "claude_code": {
      "type": "object",
      "properties": {
        "mcp": {
          "type": "boolean"
        },
        "commands": {
          "type": "boolean"
        },
        "skills": {
          "type": "boolean"
        },
        "agents": {
          "type": "boolean"
        },
        "hooks": {
          "type": "boolean"
        },
        "plugins": {
          "type": "boolean"
        },
        "plugins_override": {
          "type": "object",
          "propertyNames": {
            "type": "string"
          },
          "additionalProperties": {
            "type": "boolean"
          }
        }
      }
    },
    "sisyphus_agent": {
      "type": "object",
      "properties": {
        "disabled": {
          "type": "boolean"
        },
        "default_builder_enabled": {
          "type": "boolean"
        },
        "planner_enabled": {
          "type": "boolean"
        },
        "replace_plan": {
          "type": "boolean"
        }
      }
    },
    "comment_checker": {
      "type": "object",
      "properties": {
        "custom_prompt": {
          "type": "string"
        }
      }
    },
    "experimental": {
      "type": "object",
      "properties": {
        "aggressive_truncation": {
          "type": "boolean"
        },
        "auto_resume": {
          "type": "boolean"
        },
        "preemptive_compaction": {
          "type": "boolean"
        },
        "preemptive_compaction_threshold": {
          "type": "number",
          "minimum": 0.5,
          "maximum": 0.95
        },
        "truncate_all_tool_outputs": {
          "type": "boolean"
        },
        "dynamic_context_pruning": {
          "type": "object",
          "properties": {
            "enabled": {
              "default": false,
              "type": "boolean"
            },
            "notification": {
              "default": "detailed",
              "type": "string",
              "enum": [
                "off",
                "minimal",
                "detailed"
              ]
            },
            "turn_protection": {
              "type": "object",
              "properties": {
                "enabled": {
                  "default": true,
                  "type": "boolean"
                },
                "turns": {
                  "default": 3,
                  "type": "number",
                  "minimum": 1,
                  "maximum": 10
                }
              }
            },
            "protected_tools": {
              "default": [
                "task",
                "todowrite",
                "todoread",
                "lsp_rename",
                "session_read",
                "session_write",
                "session_search"
              ],
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "strategies": {
              "type": "object",
              "properties": {
                "deduplication": {
                  "type": "object",
                  "properties": {
                    "enabled": {
                      "default": true,
                      "type": "boolean"
                    }
                  }
                },
                "supersede_writes": {
                  "type": "object",
                  "properties": {
                    "enabled": {
                      "default": true,
                      "type": "boolean"
                    },
                    "aggressive": {
                      "default": false,
                      "type": "boolean"
                    }
                  }
                },
                "purge_errors": {
                  "type": "object",
                  "properties": {
                    "enabled": {
                      "default": true,
                      "type": "boolean"
                    },
                    "turns": {
                      "default": 5,
                      "type": "number",
                      "minimum": 1,
                      "maximum": 20
                    }
                  }
                }
              }
            }
          }
        },
        "dcp_for_compaction": {
          "type": "boolean"
        }
      }
    },
    "auto_update": {
      "type": "boolean"
    },
    "skills": {
      "anyOf": [
        {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        {
          "allOf": [
            {
              "type": "object",
              "propertyNames": {
                "type": "string"
              },
              "additionalProperties": {
                "anyOf": [
                  {
                    "type": "boolean"
                  },
                  {
                    "type": "object",
                    "properties": {
                      "description": {
                        "type": "string"
                      },
                      "template": {
                        "type": "string"
                      },
                      "from": {
                        "type": "string"
                      },
                      "model": {
                        "type": "string"
                      },
                      "agent": {
                        "type": "string"
                      },
                      "subtask": {
                        "type": "boolean"
                      },
                      "argument-hint": {
                        "type": "string"
                      },
                      "license": {
                        "type": "string"
                      },
                      "compatibility": {
                        "type": "string"
                      },
                      "metadata": {
                        "type": "object",
                        "propertyNames": {
                          "type": "string"
                        },
                        "additionalProperties": {}
                      },
                      "allowed-tools": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "disable": {
                        "type": "boolean"
                      }
                    }
                  }
                ]
              }
            },
            {
              "type": "object",
              "properties": {
                "sources": {
                  "type": "array",
                  "items": {
                    "anyOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "object",
                        "properties": {
                          "path": {
                            "type": "string"
                          },
                          "recursive": {
                            "type": "boolean"
                          },
                          "glob": {
                            "type": "string"
                          }
                        },
                        "required": [
                          "path"
                        ]
                      }
                    ]
                  }
                },
                "enable": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "disable": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          ]
        }
      ]
    },
    "ralph_loop": {
      "type": "object",
      "properties": {
        "enabled": {
          "default": false,
          "type": "boolean"
        },
        "default_max_iterations": {
          "default": 100,
          "type": "number",
          "minimum": 1,
          "maximum": 1000
        },
        "state_dir": {
          "type": "string"
        }
      }
    },
    "background_task": {
      "type": "object",
      "properties": {
        "defaultConcurrency": {
          "type": "number",
          "minimum": 1
        },
        "providerConcurrency": {
          "type": "object",
          "propertyNames": {
            "type": "string"
          },
          "additionalProperties": {
            "type": "number",
            "minimum": 1
          }
        },
        "modelConcurrency": {
          "type": "object",
          "propertyNames": {
            "type": "string"
          },
          "additionalProperties": {
            "type": "number",
            "minimum": 1
          }
        }
      }
    },
    "notification": {
      "type": "object",
      "properties": {
        "force_enable": {
          "type": "boolean"
        }
      }
    },
    "git_master": {
      "type": "object",
      "properties": {
        "commit_footer": {
          "default": true,
          "type": "boolean"
        },
        "include_co_authored_by": {
          "default": true,
          "type": "boolean"
        }
      }
    }
  }
}
</file>


---

## Instructions

Please analyze the provided information and:

1. Understand the task requirements
2. Review the project structure
3. Consider the specified rules and constraints
4. Provide a detailed solution


